---
title: "Руководство"
# subtitle: "по настройке инженерского компьютера"
subtitle: "по настройке компьютера инженера"
author: "Денис Тельнов"
license: "CC BY-NC-SA"
pdf-engine: lualatex
engine: julia
execute:
  freeze: false
  cache: false

format:

  html:
    toc: true
    # shift-heading-level-by: -1
    toc-depth: 2
    toc-location: right-body
    number-sections: true
    embed-resources: true
    link-external-newwindow: true
    mainfont: OpenSansSemiCondensed Nerd Font Propo
    sansfont: OpenSansSemiCondensed Nerd Font Propo
    # monofont: D2CodingLigature Nerd Font
    monofont: Iosevka Nerd Font
    # monofont: IosevkaTerm NF
    page-layout: full
    fig-width: 7      # in inches
    fig-height: 5.625 # in inches

  pdf:
    # top-level-division: part
    # shift-heading-level-by: -1
    # keep-tex: true
    # latex-clean: false
    papersize: A4
    # papersize: letter
    documentclass: scrartcl
    # documentclass: article
    toc: true
    number-sections: true
    colorlinks: true
    # mainfont: Open Sans SemiCondensed
    # sansfont: Open Sans SemiCondensed
    mainfont: OpenSansSemiCondensed Nerd Font Propo
    sansfont: OpenSansSemiCondensed Nerd Font Propo
    # fonts list by width
    monofont: UbuntuCondensed Nerd Font
    # monofont: D2CodingLigature Nerd Font
    # monofont: IosevkaTerm NF
    # monofont: ZedMono Nerd Font Mono
    # monofont: M+1Code Nerd Font Mono
    # monofont: Monoid Nerd Font Mono
    # monofont: Sudo
    # monofont: InputMonoCondensed Nerd Font
    # monofont: Bitstream Vera Sans Mono
    # monofont: Inconsolata LGC Nerd Font Mono
    # monofont: UbuntuSansMono Nerd Font
    # monofont: RobotoMono Nerd Font Mono
    # monofont: CaskaydiaCove Nerd Font Mono
    monofontoptions:
      - Color=39729E
      # - WordSpace=1.0
      - WordSpace=1.0,1.0,1.0
      # - FakeStretch=.75
    highlight-style: github
    code-block-border-left: "#808080"
    code-block-bg: "#FAFAFA"
    tbl-colwidths: auto
    # listings: true # Didn't worked!
    lang: ru
    output-file: win11-for-engineers-manual.pdf

from: markdown+tex_math_single_backslash
---

```{julia}
#| echo: false
#| include: false
import Pkg
# project should be already activated by metadata option: julia.exeflags: ["--project=@."]
if !(Base.active_project() !== nothing && !startswith(Base.active_project(), Base.Sys.BINDIR))
    Pkg.activate(".")
end
Pkg.add("CondaPkg")
Pkg.add("PythonCall")
Pkg.add("Plots")
Pkg.add("LaTeXStrings")
import CondaPkg
CondaPkg.add("numpy")
CondaPkg.add("matplotlib")
using PythonCall
```

{{< pagebreak >}}

*Опубликовано под лицензией [CC-BY-NC-SA](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.ru).*

*Version: 0.5.5*

# **_Этап 1: Установка базового набора рабочих программ_** {.unnumbered}

> _Preface: без использования SSD нормальной работы разработчика не получится, даже если удастся (хватит терпения) установить все необходимые программы :(_

# Установка Windows 11 и MSOffice

## Информация о продуктах Microsoft

### Лицензия

В последние годы стало возможным приобрести недорогие OEM лицензии на продукты Microsoft, на Озоне или Вайлдбериз, поэтому у пользователей появился выбор между покупкой "коробочных" (Retail) лицензий, и более дешёвых OEM лицензий.

Лицензии OEM --- это лицензии на ПО, поставляемые производителями и сборщиками техники вместе с новыми ноутбуками и компьютерами. Microsoft выделяет производителям техники целые пулы OEM лицензий по небольшой цене. И, по Европейским законам, производители могут продавать не только продукт целиком, но и комплектующие к нему, и, в данном случае, они могут продавать эти лицензии отдельно от компьютерной техники. Каждая OEM лицензия входит в какой-то конкретный пул лицензий, который закреплён за конкретным производителем, т.е., OEM, это не какая-то абстрактная безликая лицензия, а выпущенная определённым производителем. В целом, покупка OEM лицензии достаточно безопасна, случаев отзыва пулов лицензий очень и очень немного. Но, как и любую другую электронную продукцию, OEM лицензии необходимо покупать только у проверенных продавцов со множеством отзывов, но это обычные издержки электронной торговли. Из особенностей OEM лицензии следует отметить, что она, в отличии от Retail или Volume лицензий, "одноразовая", то есть, активировав её один раз, _ключ_ нельзя применить второй раз, и программу нельзя будет переустановить или перенести на другой компьютер.

Подробнее про лицензии Microsoft в [Приложении](#oem-retail-или-volume).


### Выбор версий продуктов Microsoft

Поддержка Windows 10 закончится осенью 2025, после чего, скорее всего, интернет заполонят вирусы для этой версии Windows из-за отсутствия обновлений безопасности. Поэтому рекомендуется изначально устанавливать Windows 11.

Для русскоговорящих пользователей следует устанавливать следует _En_ версию Windows 11 Pro. А\ русский язык можно будет добавить после установки, даже полностью сменить интерфейс на русский. Если устанавливать сразу _Ru_ версию, то в процессе установки будут созданы папки с русскими буквами в путях (_Документы_ и т.д.), из-за чего не будут работать некоторые инженерные (_HPC_) программы. По этой же причине, в случае установки Windows версии Home, также следует устанавливать English версию, даже не смотря на то, что в Home-версии Windows язык интерфейса сменить не удастся. Так же, не следует использовать кириллицу в имени пользователя --- это гарантированный способ сломать работоспособность инженерных программ, компиляторов; это настолько катастрофично, что, рано или поздно, но систему придётся переустановить.

Для установки рекомендуется использовать версию _build 22631.3296_ (_23H2_). Это версия, с одной стороны, достаточно свежая, чтобы были драйвера для новых моделей ноутбуков, а с другой стороны, эта версия всё ещё позволяет при установке создать локальную учётную запись, и провести установку при отсутствии интернета.

_Note:_ Для создания локальной учётной записи можно использовать и более новые версии Windows, при создании загрузочной флешки при помощи утилиты _Rufus_, см. следующий пункт.


Выбор версии и дистрибутива MSOffice:

* если не используется MS Access, то Office Home или Student _абсолютно достаточно_;
* если уже установлен офис версии 2016 (или новее) и он устраивает, то обновляться не требуется;
* если офис не установлен, то следует устанавливать самую последнюю версию (2024) с канала _Current_.

Подробности в [_Приложении Выбор версии MSOffice_](#выбор-версии-msoffice).



### Как получить дистрибутивы Windows и MSOffice

На данный момент все инсталяторы для [продуктов Microsoft загружаются через интернет](https://www.microsoft.com/en-us/download), это официальный рекомендуемый способ установки --- диски отошли в прошлое. Ссылки на [загрузку Windows](https://www.microsoft.com/en-us/download/windows), [загрузку MS Office](https://www.microsoft.com/en-us/download/office).

На самом деле, приведённые выше ссылки не работают. Во-первых, из-за санкций, которые ограничивают загрузку напрямую, непосредственно с сайта Microsoft (хотя никакого запрета на продажу или использование лицензий Microsoft не существует). Во-вторых, из-за того, что Microsoft продвигает только самую последнюю версию *Windows 11* (глючный *24H2*?), и только онлайн-офис *Office 365*, то, нормальную версию *Windows*, и обычный автономный *MSOffice* не загрузить напрямую со страниц сайта Microsoft.

Поэтому, в данном руководстве в _Приложении_ приводятся специальные процедуры загрузки продуктов с сайта Microsoft:

* [UUP (Unified Update Platform)](#uup-unified-update-platform-загрузка-ms-windows) --- загрузка MS Windows;
* [ODT (Office Deployment Tool)](#odt-office-deployment-tool-загрузка-ms-office) --- загрузка MS Office.

Подготовить загрузочную флешку из полученного iso-образа можно с помощью утилиты [**Rufus**](https://rufus.ie/) под Windows, либо [**mkusb**](https://help.ubuntu.com/community/mkusb) под Linux.

_Rufus_ позволяет при создании загрузочной флешки сделать _Customize Windows Installation_, а именно _запрет_ на: проверку ограничений, сбор данных (телеметрию), онлайн регистрацию. При выборе типа загрузки следует выбирать _GPT/SecureBoot_, а не _MBR/Legacy_ (который предназначен для очень старых компьютеров). _Note:_ Запрет на онлайн регистрацию означает, что будет создана локальная учётная запись, и что установку Windows возможно провести без подключения к сети интернет.


## Установка и настройка Windows

_Note:_ [BitLocker](https://learn.microsoft.com/ru-ru/windows/security/operating-system-security/data-protection/bitlocker/) --- это встроенный в Windows механизм шифрования дисков для обеспечения безопасности информации. По умолчанию, при использовании учётной записи Microsoft, диски были автоматически зашифрованы. И, в случае переустановки Windows важно убедиться, что ключи шифрования сохранены и доступны для использования. При установке Windows на новые диски это не актуально. Подробности в _Приложении_ [_BitLocker_](#bitlocker).

Для начала установки необходимо загрузиться с загрузочной флешки с инсталятором Windows. Для установки потребуется подключение к интернет для входа в учётную запись Microsoft (или создания новой), если только заранее не были предприняты специальные действия.

_\<Upd 2025\>:_ Создать локальную учётную запись в процессе установки можно следующими командами: во время запроса на ввод учётной записи нажать `Shift + F10`, открыть командную строку, набрать и выполнить команду `start ms-cxh:localonly`. Нет гарантий, что этот метод в будущем не перестанет работать.

После установки потребуется единоразово понастраивать свойства и интерфейс Windows:

* Разрешить _Windows Development Mode_: (~~_Settings > Update & Security > For Developers:_~~) _Settings > System > For Developers: Developer Mode -> On_

* Также, для разработчиков, для поддержки длинных имён файлов выполнить в PowerShell(Admin):\
  ```powershell
  Set-ItemProperty 'HKLM:\SYSTEM\CurrentControlSet\Control\FileSystem' -Name 'LongPathsEnabled' -Value 1
  ```

* После активации появится возможность переместить меню Старт влево: _Setting > Personalization > TaskBar > Taskbar behaviors > Taskbar alignment_.

* Отключить режим гибернации (hibernate): в Cmd/PowerShell(Admin) выполнить:\
  ```powershell
  powercfg /H off
  ```

* После установки региона _Россия_ Windows настроит все соответствующие параметры, в том числе, установит запятую в качестве десятичного разделителя. Поправить на точку можно в _ControlPannel_, раздел _Region > Additional Settings... > Decimal Symbol_.

* Настройка действия на складывание ноутбука --- поиском в меню Start слова _Lid_. Рекомендуется настроить везде Sleep, и при работе от аккумулятора, и при работе от сети. Современный ноутбук при постоянном использовании можно вообще никогда не выключать, а только переводить в сон.


* Поведение `<Alt+Tab>` --- показывать ли отдельные _Табы_ в списке окон по `<Alt+Tab>`: _Settings > System > Mutitasking: Show tabs from apps..._, установить в _Don't show tabs_, тогда по `<Alt+Tab>` будут показываться только окна, без составляющих их табов.

* Включить встроенный многокарманный буфер обмена (Clipboard) в Windows --- `Win+V` (_Note:_ этот буфер очищается при перезагрузке!, поэтому, лучше использовать сторонний буфер обмена [CopyQ](#многокарманный-буфер-обмена)).

* _Windows Update > Advanced Options >_ включить _Receive Updates for other Microsoft products_. Это чтобы MSOffice тоже обновлялся.

* После установки всех программ отредактировать список программ запускаемых при загрузке: _Settings > Apps > StartUp_.

* Правой клавишей по трею > _Taskbar settings > Other system tray icons_, выбрать постоянно показываемые иконки:\
  _Safely Remove Hardware..._\
  _Windows Update Status_\
  Плюс ещё какие нужные программы, а остальные спрятать чтобы не мешали.

* Настройка вида меню Start: _Settings > Personalization > Start_.

* В меню Start в нижней строке можно расположить быстрый доступ к Папкам и _Settings_: _Personalization > Start > Folders_.

* Если Edge не используется, то есть пара утилит на случай, если Edge станет совсем занудным своими напоминаниями: [GoAwayEdge](https://github.com/valnoxy/GoAwayEdge) и [MSEdgeRedirect](https://github.com/rcmaehl/MSEdgeRedirect), которые отключают Edge и регулярно проверяют, чтобы Edge больше не просыпался.

* Высокое время задержки перед повтором нажатия клавиш (если не помогает стандартный метод _ControlPanel > Keyboard: Repeat delay_) [правится](https://www.reddit.com/r/techsupport/comments/1du2gvd/keyboard_repeat_delay_keeps_setting_itself_to_its/) в реестре:\
  `regedit`: `HKEY_CURRENT_USER>Control Panel>Accessibility>Keyboard Response`:
  ```default
  AutoRepeatDelay 200
  AutoRepeatRate 5
  BounceTime 0
  DelayBeforeAcceptance 10
  Flags 59
  ```
  Эти настройки могут слетать (при каждом обновлении Windows11?), поэтому, если ситуация будет повторяться, то надо сделать _.reg_ файл для этого раздела регистра, и применять его, когда задержка перед повтором опять станет длительной. См. также [Настройки](https://learn.microsoft.com/en-us/answers/questions/1124213/registry-keyboard-response-default-values). В общем, с этой задержкой перед повтором нажатий клавиш в Windows 11 какой-то баг, и, я полагаю, проблема разрешится с очередным обновлением.

* После полной переустановки Windows, если были данные на диске D: и т.д., то может возникнуть проблема с доступом к старым данным, которые обусловлены несовпадением новых идентификаторов пользователя со старыми идентификаторами. В этом случае необходимо установить права доступа по умолчанию ([подробности *icacls*](https://learn.microsoft.com/ru-ru/windows-server/administration/windows-commands/icacls)), для этого запустить с правами Администратора команду:\
  ```powershell
  icacls D:\ /reset /t /c /l
  ```

* Для продвинутых пользователей есть утилита [Winutil](https://github.com/ChrisTitusTech/winutil) с широкими возможностями по [установке и удаления утилит и программ](https://christitustech.github.io/winutil/userguide/#__tabbed_1_1), по [тюнингу](https://christitustech.github.io/winutil/userguide/#tweaks) и [настройке](https://christitustech.github.io/winutil/userguide/#config) Windows, отключения телеметрии, и прочему. [Установка](https://christitustech.github.io/winutil/KnownIssues/#script-blocked-by-execution-policy) в PowerShell от Администратора (Admin!):
  ```powershell
  Set-ExecutionPolicy Unrestricted -Scope Process -Force
  irm https://github.com/ChrisTitusTech/winutil/releases/latest/download/winutil.ps1 | iex
  ```
  Запуск через меню _Пуск_: `Winutil`.\
  Перед применением рекомендуется сделать бекап системы.

* Для продвинутых пользователей есть утилита [Win11Debloat](https://github.com/Raphire/Win11Debloat) для отключения телеметрии и удаления ненужных предустановленных программ. Этот скрипт имеет три режима работы, в одном из которых (_3-ем_) предлагается список предустановленного софта, где можно выбрать галочками что удалить  а что оставить. Перед применением _крайне_ рекомендуется сделать бекап системы.

# Справочные материалы по системе Windows

[Windows 10/11 Guide. Including Windows Security tools, Encryption, Nextcloud, Graphics, Gaming, Virtualization, Windows Subsystem for Linux (WSL 2), Software Apps, and Resources.](https://github.com/mikeroyal/Windows-11-Guide)

[Awesome list dedicated to Windows Subsystem for Linux.](https://github.com/sirredbeard/awesome-wsl)

## Клавиши быстрого доступа (shortcut keys) в Windows

Полный список [комбинаций клавиш быстрого доступа Windows](https://support.microsoft.com/help/12445), [ещё один](https://www.windowscentral.com/best-windows-10-keyboard-shortcuts), [и ещё один](https://answers.microsoft.com/en-us/windows/forum/all/73-keyboard-shortcuts-in-windows/1a56279c-752a-4d2e-8223-2b31b643ebaa).


### Переключение окон

`Win+#Digit`: `Win+1`, `Win+2`, и т.д. --- быстрое переключение на приложение номер _#Digit_ в _Панели Задач_/_Taskbar_. Если в _Панели Задач_ закреплено (_pin_) несколько приложений, например: _FileExplorer_, _Edge_ и _Far_, то, нажатие на `Win+3` переключит на первый открытый _Far_, сколько бы ни было открыто слева окон проводников или браузеров. Повторное нажатие на `Win+3` переключит на следующий открытый _Far_, и т.д.

То есть, закрепив в _Панели Задач_ наиболее часто используемые приложения, их всегда можно сходу вызвать по их порядковому номеру соответствующей горячей клавишей `Win+Номер`.

### Переключение вкладок

В Windows во всех приложениях быстрый доступ к конкретной _Вкладке_/_Табу_ (_Tab_)  проводится по комбинации `Ctrl+#Digit`, т.е. `Ctrl+1`, `Ctrl+2` и т.д. (кроме _Windows Terminal_, где `Ctrl+Alt+1`)

По `Ctrl+Tab` --- листание _Вкладок_/_Табов_. `Ctrl+Shift+Tab` --- листание _Вкладок_ в обратном порядке.

### Остальные команды

* `Ctrl+D` --- свернуть все окна
* `Ctrl+Esc` --- меню Start (Пуск)
* `Ctrl+Shift+Esc` --- вызвать Task Manager (Менеджер Задач)
* `Win+E` --- открыть новый File Explorer (Проводник)


_Note:_ [Guide](https://www.geeksforgeeks.org/enable-and-disable-keyboard-shortcuts/), как включить или выключить те или иные комбинаций клавиш быстрого доступа Windows.

_Note:_ Для очень продвинутых пользователей может быть интересна утилита [AutoHotKey](https://www.autohotkey.com/), которая позволяет запрограммировать любые действия на любые клавиши.


# Установка программ

Менеджеры программ для Windows: [**Scoop**](https://scoop.sh/#/) (консольная), [**WinGet**](https://github.com/microsoft/winget-cli) (консольная), [**Chocolatey**](https://chocolatey.org/) (есть GUI). Потребуются все три менеджера, так как не все программы есть в каком-то одном менеджере. На сайте <https://repology.org/projects/> есть сведения практически обо всех существующих программах распространяемых через интернет. Также там можно определить в каких репозиториях есть интересующая программа.

Существует [UniGetUI](https://github.com/marticliment/UniGetUI) --- графический интерфейс к большинству менеджеров программ, но не всегда ставится (из-за санкций), не надёжен.

_Все консольные программы_ надо устанавливать через _Scoop_, при этом программы будут установлены в домашнюю папку, и пути будут добавлены в переменную _PATH_, что автоматически позволит запускать эти программы из командной строки.

_Графические программы_ следует устанавливать либо через _WinGet_, либо через _Chocolatey_ --- примерно одно и тоже. Через _winget_ стоит устанавливать те программы, которым не требуется регулярное обновление, либо которые умеют сами обновляться, например Telegram --- установил и забыл. Если программы требуют регулярного контроля над обновлениями, то это удобнее делать через _ChocolateyGUI._

> В общем, все консольные программы устанавливать через _Scoop_, все не консольные программы ставить через _WinGet_, а через _Chocolatey_ устанавливать то, чего нет в _WinGet_.

_Note:_ *Видимость установленных программ менеджерами программ.* _Scoop_ "видит" только те программы, что установил сам. _Winget_ помимо программ, которые были им установлены, также "видит" программы, установленные через _Chocolatey_; для _Chocolatey_ обратное неверно --- если программа установлена не через _Chocolatey_, то она её не "видит".

**_Note:_ Большинство программ в этом руководстве являются _программами с открытым исходным кодом_. Обо всех _проприетарных_ программах есть явная пометка об этом.**

**_Note:_ В данном руководстве везде предполагается использование _cmd.exe_ (_Clink_) в качестве терминала для выполнения команд, если только явно не указано иное.**

**_Note:_ Списки установки программ в последующих трёх разделах устанавливают практически все программы, рассматриваемые в данном руководстве, кроме тех излишне больших программ, решение об установке которых должен принимать пользователь из-за размера занимаемого места. (*\<TBD\>*: синхронизировать списки и пометить по тексту что уже установлено)**

## Scoop

<https://scoop.sh/#/apps> --- сайт-каталог доступных программ.

Установка scoop с сайта <https://scoop.sh/> --- запустить две строчки в _PowerShell_ (не Admin!):
```powershell
Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser
Invoke-RestMethod -Uri https://get.scoop.sh | Invoke-Expression
```
После выполнить проверку:
```cmd
scoop checkup
```
Здесь потребуется пара настроек Windows для _Developer Mode_ и _LongPaths_, если они не были сделаны при установке Windows.

Установить все программы --- в любом терминале (не Admin) выполнить:

```cmd
scoop install git
scoop update

scoop config aria2-enabled false

scoop bucket add nerd-fonts
scoop install nerd-fonts/IosevkaTerm-NF-Mono
scoop install busybox
scoop install fd
scoop install ripgrep
scoop install fzf
scoop install ccat
scoop install btop
scoop install wttop
scoop install 7zip
scoop install curl
scoop install gcc
scoop install gdb
scoop install make
scoop install cmake
scoop install time
scoop install clipboard
scoop install imagemagick
scoop install ffmpeg
scoop install handbrake-cli
scoop install openssh
#scoop install cwrsync
scoop install concfg
scoop install neovim

scoop install python

scoop install winget

scoop bucket add extras
scoop install gnuplot
```


## Winget

Список доступных к установке программ:\
<https://winstall.app/>

_winget_ уже должен быть установлен с помощью _scoop_:\
`scoop install winget`.

Устанавливать программы из под пользователя, а не Admin!, при необходимости _winget_ сам спросит права.

```cmd
winget install --id=FarManager.FarManager -e
winget install --id=Hibbiki.Chromium -e
winget install --id=Mozilla.Firefox.ESR -e
winget install --id=Chocolatey.Chocolatey -e
winget install --id=OpenVPNTechnologies.OpenVPN -e
winget install --id=AutoHotkey.AutoHotkey -e
winget install --id=Microsoft.PowerShell -e
winget install --id=Microsoft.WindowsTerminal -e
winget install --id=nomacs.nomacs -e
winget install --id=xiaoyifang.GoldenDict-ng -e
winget install --id=WinDirStat.WinDirStat -e
winget install --id=PuTTY.PuTTY -e
winget install --id=Telegram.TelegramDesktop -e
winget install --id=Meld.Meld -e
winget install --id=WinMerge.WinMerge -e
winget install --id=Qalculate.Qalculate -e
winget install --id=Rufus.Rufus -e
winget install --id=hluk.CopyQ -e
winget install --id=FreeCAD.FreeCAD -e
winget install --id=KDE.LabPlot -e
```

## Chocolatey

<https://community.chocolatey.org/packages> --- каталог программ в _Chocolatey_.

_Chocolatey_ уже был установлен с помощью _winget_:\
`winget install --id=Chocolatey.Chocolatey -e`{.cmd}

Для установки _GUI_ для _Chocolatey_ запустить в Admin терминале:
```cmd
choco install -y chocolateygui
```

_Note:_ В настройках ChocolateyGUI (запускается уже из меню Start) лучше отключить вид в виде tiles/плиток --- построчный показ удобнее.

В _Chocolatey_ из терминала (так удобнее) --- установить программы (Admin!):
```cmd
choco install -y vcredist-all
choco install -y reflect-free
choco install -y vcxsrv
```

_Note:_ В консольных терминалах для выполнения программ под правами _Admin_ следует вставлять _sudo_ перед командой, например: `sudo choco install -y vcredist-all`{.cmd}.

В _ChocolateyGUI_, в репозитории, эти программы также можно найти и установить вручную:

* Microsoft Visual C++ Runtime - all versions
* Macrium Reflect
* VcXsrv Windows X Server

## Обновление (update) всех установленных в Windows программ

Все менеджеры программ предоставляют возможность обновить все программы одной командой --- для этого выполнить в терминале (не Admin!):
```cmd
scoop update --all
sudo choco update all -y
winget update --all
```

* _Scoop_ может обновить только то, что он сам установил: `scoop list`. Обновить реестр программ и обновлений: `scoop update`, вывести список обновляемого: `scoop status`. Обновить всё: `scoop update --all`.

* _Chocolatey_ может обновить только то, что он сам установил. В ChocolateyGUI при запуске он покажет, что можно обновить: нажать иконку-звёздочку. Обновить из CLI: `sudo choco update all -y`.

* _Winget_ может обновить программы, которые были установлены и через winget, и через Chocolatey, список установленного: `winget list`, при наличии обновления эта команда укажет новую версию; либо, сразу показать список с доступными обновлениями: `winget update`. Обновить всё: `winget update --all`.


_Note_: Есть утилита, [**topgrade**](https://github.com/topgrade-rs/topgrade), которая апдейтит _абсолютно всё_: обновления Windows, драйвера, прошивки, scoop/choco/winget программы, всё вплоть до плагинов VSCode. Перед применением обязательно сделать бекап (например с помощью MacriumReflect), иначе, _topgrade_ порой такое обновляет, что совсем не радует, например, до последнего обновления Win11. По хорошему, _topgrade_ необходимо сначала поконфигурить, что обновлять, а что нет, и только потом запускать. Установка: `scoop install topgrade`, запуск: `topgrade`.


## Некоторые программы и утилиты

Несколько параграфов о разных программах и утилитах, которые не требуют подробного описания установки или использования. Большинство из них были в списках установки выше, т.е. _уже_ были установлены.


### Программы для картинок

[**nomacs**](<https://nomacs.org/>) --- программа для просмотра изображений; а также для их модификации, с широчайшими возможностями: конвертация, масштабирование, вращение, обрезка, работа с цветом, баланс белого, работа с raw форматами, интерактивная обработка нескольких изображений синхронно. Конечно, не фотошоп, но для обычной работы с картинками 99% необходимого функционала обеспечивает.

```cmd
winget install --id=nomacs.nomacs -e
```

[**Gimp**](https://docs.gimp.org/2.4/ru/gimp-concepts-usage.html) --- opensource замена фотошопу; программа для тех, кому не достаточно возможностей *nomacs*.

```cmd
winget install --id=GIMP.GIMP -e
```

### pdf-viewer

Если бы не было просмотра _pdf_ в каждом браузере, то можно было бы установить [Sumatra PDF](https://www.sumatrapdfreader.org/free-pdf-reader):
```cmd
winget install --id=SumatraPDF.SumatraPDF -e
```
но сейчас это уже излишне.



### Программки для работы с текстом

Офисные программы рассмотрены в отдельной главе [_Офисные Пакеты_](#офисные-пакеты). Написание программных кодов предполагается в _VSCode_, настройка которого рассмотрена в отдельной [_главе_](#настройка-среды-для-программирования).

* [**Notepad++**](https://notepad-plus-plus.org/) --- легковесная замена блокнота, ультраэдита, и проч., с подсветкой синтаксиса, широкими возможностями редактирования. Устанавливается: `scoop install extras/notepadplusplus`{.cmd}.

* [**Meld**](https://meldmerge.org/) и [**WinMerge**](https://winmerge.org/) --- это программы для сравнения и редактирования файлов бок о бок, наиболее популярные из открытых. Используются, в том числе, для разрешения конфликтов при слияниях *git*. Устанавливаются, соответственно: `winget install --id=Meld.Meld -e`{.cmd} и `scoop install extras/winmerge`{.cmd}.

* [**GoldenDict-ng**](https://xiaoyifang.github.io/goldendict-ng/) --- локальные словари для перевода. По умолчанию активируется (переводит) по двойному нажатию на `<Ctrl+C>`. [Устанавливается](https://winstall.app/apps/xiaoyifang.GoldenDict-ng) так: `winget install --id=xiaoyifang.GoldenDict-ng -e`{.cmd}; но при установке никаких словарей не ставится, их необходимо дополнительно скачать и указать программе где они, скачанные, лежат.
  Свободные словари:
  - dict-freedict-eng-rus  - English-Russian dictionary for the dict server/client
  - mueller7-dict          - Mueller English/Russian dictionary in dict format
  - *\<TBD\>*

### Утилиты для работы с дисками

* [**WinDirStat**](https://windirstat.net/) --- утилита для контроля занимаемого места файлами на диске, показывает размер файлов в виде плиток. Установка: `winget install --id=WinDirStat.WinDirStat -e`{.cmd}

* [**Rufus**](https://rufus.ie/) --- утилита для создания загрузочных флешек, для установки операционных систем Windows, Linux и пр. Установка: `winget install --id=Rufus.Rufus -e`.

* [**GSmartControl**](https://gsmartcontrol.shaduri.dev/) --- утилита для получения информации *S.M.A.R.T. SSD/HDD*, в частности, для контроля истирания *SSD*. Установка: `winget install --id=AlexanderShaduri.GSmartControl -e`{.cmd}

* обновление прошивок **SSD**:
  - _[Samsung](https://semiconductor.samsung.com/consumer-storage/support/tools/)_: `sudo choco install -y samsung-magician`
  - _[Intel](https://www.solidigm.com/support-page/drivers-downloads/ka-00085.html)_: `winget install --id=Solidigm.StorageTool -e`
  - _[Transcend](https://www.transcend-info.com/Support/Software-10/)_: `winget install --id=TransendInfo.SSDScopeApp -e`
  - _[Kingston](https://www.kingston.com/en/support/technical/ssdmanager)_: `winget install --id=Kingston.SSDManager -e`
  - _[Micron](https://www.micron.com/products/storage/ssd/micron-ssd-firmware)_, [2](https://www.micron.com/sales-support/downloads/software-drivers/storage-executive-software): `sudo choco install -y micron-storage-executive`
  - _[Crucial](https://www.crucial.com/support/storage-executive)_: `winget install --id=Crucial.StorageExecutive -e`
  - _[WD](https://support-en.wd.com/app/answers/detailweb/a_id/31759)_: `winget install --id=WesternDigital.Dashboard -e`

### Прочие системные утилиты

* для ноутбуков **Lenovo** есть утилита [Lenovo System Update](https://support.lenovo.com/us/en/downloads/ds012808-lenovo-system-update-for-windows-10-7-32-bit-64-bit-desktop-notebook-workstation), которая может скачать/обновить BIOS и специфичные драйвера для Windows. [Установка](https://winstall.app/apps/Lenovo.SystemUpdate): `winget install --id=Lenovo.SystemUpdate -e`. [Ещё вариант](https://winstall.app/apps/Lenovo.UpdateRetriever).

* для ноутбуков **Huawei** есть утилита [PC Clone](https://winstall.app/apps/Huawei.PCClone) для копирования системы с/на другие компьютеры и ноутбуки. Копирование происходит: а) копированием всех файлов пользователя, б) установкой соответствующих программ на другом компьютере и копировании данных для каждой из этих программ (поддерживается ограниченный список программ). Должна работать не только с Huawei.

* [**FanControl**](https://getfancontrol.com/) --- утилита для настройки скорости вращения вентиляторов, актуально для ноутбуков, подходит не для всех ноутбуков, особенно свежих моделей; [установка](https://winstall.app/apps/Rem0o.FanControl): `winget install --id=Rem0o.FanControl -e`.


### Драйвера

Если какое-то устройство не работает, или знаки вопроса в _Device Manager_, то можно попробовать поставить драйвера (без гарантии что заработает и ничего не сломается, и сначала сделать бэкап).

[**HW-Info**](https://www.hwinfo.com/) --- бесплатная _проприетарная_ утилита, выводит список наличных аппаратных устройств:
```cmd
winget install --id=REALiX.HWiNFO -e
```

**SDIO** <https://www.snappy-driver-installer.org/>^[не ~~**SDI**~~!] --- Установщик драйверов:
```cmd
winget install --id=samlab-ws.SnappyDriverInstaller -e
```


## Backup операционной системы Windows

Резервное копирование систем Windows удобно делать используя программу [**MacriumReflect**](https://en.wikipedia.org/wiki/Macrium_Reflect) --- это _проприетарная_ программа, но бесплатная для персонального использования. Программа должна была быть установлена через _Chocolatey_ (см. выше):
```cmd
sudo choco install -y reflect-free
```

### Особенности использования MacriumReflect

При первом бэкапе будет создан шаблон, который, в дальнейшем, можно будет запускать безо всех этих шагов с указанием пути, имени, и т.п. Шаблон во втором табе/вкладке.

Для возможности восстановления из бэкапов необходимо создать загрузочную запись, либо на флешке, либо на самом диске с установленной операционной системой. Это делается в меню _Other Tasks > Create Rescue Media_.

В меню _Other Tasks > Edit Defaults and Settings > Update Settings_ отключить проверку обновлений --- очень часто обновляется, будет раздражать. Рядом в _Backup Defaults > Retension Rules_, стоит отключить автоматическое удаление старых бэкапов.

### duplicati

*\<TBD\>*

Open-source program, with _VSS_ support!

<https://duplicati.com/>
<https://docs.duplicati.com/>

```cmd
winget install --id=Duplicati.Duplicati  -e
```

## Браузеры

Наиболее широко распространённые браузеры: Chromium (Chrome), Firefox, Edge, Brave. Chrome, Edge, Brave созданы на основе Chromium, Firefox --- отдельная разработка. Все браузеры примерно равны, и у всех есть возможность установки наиболее востребованных плагинов. Edge и Chrome по умолчанию следят за пользователями, Chromium и Firefox не следят (так как их исходный код доступен и любой желающий параноик в этом может убедиться), но Edge и Chrome наиболее массовые браузеры, и, поэтому, наиболее протестированные и защищённые. На сегодняшний день для повседневной работы с не конфидициальными данными, в Windows вполне обосновано применять _Edge_ (с установленным плагином [_UBlock Origin_](https://microsoftedge.microsoft.com/addons/detail/ublock-origin/odfafepnkmbhccpbejgmiehpchacaeak), и настройками, запрещающими отправку данных в _Edge > Settings > Privacy, Search and Services:_).

Особенности использования современных браузеров:

* _UBlock Origin._  _"Must have"_ для всех браузеров, без вариантов! [_Edge_](https://microsoftedge.microsoft.com/addons/detail/ublock-origin/odfafepnkmbhccpbejgmiehpchacaeak), [_Chrome_/_Chromium_](https://chromewebstore.google.com/detail/ublock-origin/cjpalhdlnbpafiamejdnhcphjbkeiagm), [_Firefox_](https://addons.mozilla.org/en-US/firefox/addon/ublock-origin/). После установки плагина в настройках дополнительно включить фильтр _Ru_ в настройках плагина в табе _Filter lists_ в самом низу в _Regions, languages_.

* _NoScript._ [Во](https://addons.mozilla.org/en-US/firefox/addon/noscript/) [всех](https://chromewebstore.google.com/detail/noscript/doojmbjmlfjjnbmnoijecmcbfeoakpjm) [браузерах](https://microsoftedge.microsoft.com/addons/detail/noscript/debdhlbmgmkkfjpcglcbjadbhhekgfjh) есть [_NoScript_](https://noscript.net) плагин, который разрешает запуск каких-либо _.js_-скриптов только по _белому списку_, т.е. никакие сторонние скрипты никогда _не запустятся_, если только их не _разрешить явно_. Одно из следствий работы этого плагина, состоит в том, что, если явно не разрешать работу js-скриптов, которые отвечают за локацию местоположения пользователя, то начинают работать те сайты, которые ограничивают доступ для пользователей из России.

* В _Firefox_ есть встроенный менеджер паролей, защищённый _Мастер Паролем_, т.е. Firefox не позволяет посмотреть сохранённые пароли и реквизиты банковских карт пока не будет введён _Мастер Пароль_. У Chromium (Chrome, Edge) нет такой возможности --- они позволяют любому посмотреть все сохранённые пароли. /Параноик Mode Off.

Примерный список плагинов приведён в конце параграфа на примере _Chromium_.

Далее рассмотрим некоторые варианты использования браузеров, учитывающие их особенности.

### Конфиденциальные данные

Установить _FirefoxESR_: `winget install --id=Mozilla.Firefox.ESR -e`{.cmd}, установить _МастерПароль_, установить [_NoScript_](https://addons.mozilla.org/en-US/firefox/addon/noscript/), [_U-Block Origin_](https://addons.mozilla.org/en-US/firefox/addon/ublock-origin/). Этот браузер будет для работы с конфиденциальными данными, для работы: с почтой, банковскими сайтами, и т.п. Поначалу придётся много раз добавлять сайты в разрешённые в _NoScript_, но их всё же ограниченное число.

### Обычное использование интернета

Установить один из браузеров для работы по умолчанию (кроме уже задействованного FirefoxESR). Установить в нём все плагины, кроме _NoScript._

### Песочница

[_Brave_](https://brave.com/) позиционируется как наиболее защищённый браузер, и он может использоваться в качестве "песочницы". `winget install --id=Brave.Brave -e`{.cmd}. В настройках в brave://settings/shields включить _Aggresive_ в _Trackers & ads blocking_, и включить _Block Scripts_. В последующем использовании разрешать скрипты по очереди --- иконка щита справа от адресной строки. В браузере ни в коем случае не сохранять логинов и паролей. Тогда в этом браузере можно абсолютно безопасно посещать любые недостоверенные сайты, и это не приведёт ни к компрометации данных, ни к вирусам. Также в Brave могут открываться некоторые сайты, которые в других браузерах не открываются из-за санкций.

### Примерный набор плагинов

для браузера _Chromium_:

[_uBlock Origin_](https://chromewebstore.google.com/detail/ublock-origin/cjpalhdlnbpafiamejdnhcphjbkeiagm)\
[_Open Tabs Next to Current_](https://chromewebstore.google.com/detail/open-tabs-next-to-current/gmpnnmonpnnmnhpdldahlekfofigiffh)\
[_QR Code Generator_](https://chromewebstore.google.com/detail/qr-code-generator/afpbjjgbdimpioenaedcjgkaigggcdpp)\
[_Enable right click_](https://chromewebstore.google.com/detail/enable-right-click/hhojmcideegachlhfgfdhailpfhgknjm)\
[_History Trends Unlimited_](https://chromewebstore.google.com/detail/history-trends-unlimited/pnmchffiealhkdloeffcdnbgdnedheme)\
[_The Marvellous Suspender_](https://chromewebstore.google.com/detail/the-marvellous-suspender/noogafoofpebimajpfpamcfhoaifemoa)\
[_Unpaywall_](https://chromewebstore.google.com/detail/unpaywall/iplffkdpngmdjhlpjmppncnlhomiipha)

Для того, чтобы открывались подсанкционные сайты, например [netlib.org](https://www.netlib.org/lapack/explore-html/) --- сайт математической библиотеки LAPACK, можно попробовать следующие плагины:\
[_Runet Censorship Bypass_](https://chromewebstore.google.com/detail/%D0%BE%D0%B1%D1%85%D0%BE%D0%B4-%D0%B1%D0%BB%D0%BE%D0%BA%D0%B8%D1%80%D0%BE%D0%B2%D0%BE%D0%BA-%D1%80%D1%83%D0%BD%D0%B5%D1%82%D0%B0/npgcnondjocldhldegnakemclmfkngch)\
[_Snowflake_](https://chromewebstore.google.com/detail/snowflake/mafpmfcccpbjnhfhjnllmmalhifmlcie)

Есть плагин [_uBlacklist_](https://github.com/iorate/ublacklist#ublacklist), который позволяет исключить из выдачи поисковиков (google.com и т.д.) некоторые сайты --- заблокировать их от показа.

## Far Manager и консольный терминал

### Нулевой уровень сложности настройки

Если [**Far**](https://www.farmanager.com/) ещё не установлен, то установить:
```cmd
scoop install 7zip
winget install --id=FarManager.FarManager -e
```

_Note:_ Поменять [_шрифты_](#отступление-про-шрифты) можно кликнув правой кнопкой мыши на иконке Far, в свойствах.

_Note:_ В Far'е можно открывать [ssh-соединения](#sshputty) с поддержкой [X11 приложений](#x-server), для этого в окне терминала Far (`Ctrl+O`) вызвать две команды:
```cmd
set DISPLAY=127.0.0.1:0.0
ssh -X somename@somehost
```

### Второй уровень сложности

Запускать [**Far**](https://www.farmanager.com/) в [**WindowsTerminal**](https://learn.microsoft.com/ru-ru/windows/terminal/), в котором можно настроить цвета/палитры, [_шрифты_](#отступление-про-шрифты) и т.п.

Установить _Far_ и [_WindowsTerminal_](https://learn.microsoft.com/ru-ru/windows/terminal/install):
```cmd
scoop install 7zip
winget install --id=FarManager.FarManager -e
winget install --id=Microsoft.WindowsTerminal -e
```


#### Настройка Windows Terminal

* Добавить профиль для запуска Far: открыть WindowsTerminal _Settings_, в меню слева выбрать (внизу) _+ Add a new profile_, нажать _+ New empty profle_, задать имя профиля _Far_, в пункте _Command line_ задать выполняемую команду, выбрав файл _"C:\\Program Flies\\Far Manager\\Far.exe"_, в пункте _Starting directory_ отжать галочку (станет _%USERPROFILE%_), для отображения иконки выбрать тот же самый _"C:\\Program Flies\\Far Manager\\Far.exe"_ --- иконка будет браться непосредственно из _.exe_; сохранить. Выбрать профиль _Far_ для старта: в меню _Settings_ самый первый пункт. (Всё то же самое можно сделать через [редактирование файла конфигурации](https://learn.microsoft.com/ru-ru/windows/terminal/dynamic-profiles#far-manager) `settings.json`, подробнее чуть ниже в Пункте про схемы)

* Настроить запуск WindowsTerminal по умолчанию для всех консольных команд и приложений: в настройках Windows в _Settings > Update & Security > For developers: Terminal > Windows Terminal_.

* Тема оформления, [_Шрифт_](#отступление-про-шрифты), Форма курсора, меняются в настройках WindowsTerminal в _Settings > Defaults > Appearance_ --- это будут настройки по умолчанию для всех новых типов терминалов. Эти настройки можно будет изменить для каждого профиля терминала отдельно.

* Частоту мигания курсора можно изменить только глобально в настройках Windows: _Change cursor blinking rate_.

* В Windows Terminal для создания [ssh-соединения](#sshputty) (с поддержкой [X11 приложений](#x-server)) вызвать следующую команду прямо из _cmd_ (_clink_) сессии:
  ```cmd
  set DISPLAY=127.0.0.1:0.0& ssh -X somename@somehost
  ```
  Можно настроить отдельный профиль для фиксированного ssh-соединения, чтобы сразу открывалась новая ssh-сессия при открытии профиля. Для этого сдублировать профиль _cmd.exe_, с такой командой:
  ```cmd
  cmd.exe /c set DISPLAY=127.0.0.1:0.0& ssh -X somename@somehost
  ```
  Переменную `DISPLAY` можно установить перманентно в пользовательских переменных среды окружения командой:
  ```cmd
  setx DISPLAY 127.0.0.1:0.0
  ```

* [Использовать _PuTTY_ в Windows Terminal](https://github.com/microsoft/terminal/issues/1917#issuecomment-737710268): для того, чтобы _PuTTY_ открывал соединение и показывал всё в Windows Terminal, необходимо [настроить новый профиль](https://superuser.com/questions/1523297/open-putty-ssh-session-in-new-windows-terminal), в котором будет вызываться загрузка соответствующего профиля PuTTY командой `"plink.exe -load \"putty-session\""`. (Команда _C:\\Program Files\\PuTTY\\plink.exe_, это программа, которая осуществляет непосредственное соединение для _PuTTY_, с поддержкой ключей и _Pageant_.) Но Windows Terminal очень плохо поддерживает _plink.exe_, поэтому многие клавиши (стрелки) работать не будут.

* Дополнительные цветовые схемы см. в <https://github.com/mbadolato/iTerm2-Color-Schemes> или <https://windowsterminalthemes.dev/>. [Установка](https://learn.microsoft.com/ru-ru/windows/terminal/customize-settings/color-schemes#creating-your-own-color-scheme) дополнительных схем осуществляется вставкой соответствующего `json`-фрагмента настроек цветовой схемы в секцию `"schemes":` в общей конфигурации WindowsTerminal `settings.json`, которая открывается для редактирования по нажатию на "Шестерёнку" в левом нижнем углу в меню _Settings_.\
  Просмотреть цвета текущей схемы можно командой: `colortool -c`,  которая устанавливается: `scoop install colortool`.

* Для того, чтобы _Far_ показывал другие цветовые схемы, помимо синей, необходимо отжать галочку в меню _Far_: _F9 > Options > Colors: Palette > Classic Palette: Off_.\
  Из не синих схем интересна схема [Glacier](https://github.com/mbadolato/iTerm2-Color-Schemes/blob/master/windowsterminal/Glacier.json), например.

* Для автоматического копирования в буфер обмена выделенного мышкой включить опцию _Settings > Interaction: Automatically copy selection to clipboard_. \<new-01\>

* Не показывать Warning на _multiline paste_: [добавить строчку](https://superuser.com/questions/1677982/how-do-i-get-windows-terminal-to-stop-asking-me-every-time-i-paste-something-int) `"multiLinePasteWarning": false,` в самый верх (на первый уровень) конфига `settings.json`.

* Комбинации `Ctrl+C`, `Ctrl+V`, `Ctrl+W`, `Ctrl+T` для доступности в консольных приложениях следует перенастроить (в настройках в _Settings > Actions_) на варианты с `Shift`, т.е.: `Ctrl+Shift+C`, `Ctrl+Shift+V`, `Ctrl+Shift+W`, `Ctrl+Shift+T` и т.п.

* Для показа иконок в _Taskbar_'е в Windows должна быть включена опция _Show badges on taskbar buttons_ в _Settings > Personalization > Taskbar_.

* Одним из интересных вариантов интеграции WindowsTerminal в Windows будет настройка _Панели задач_ (_Taskbar_) без группировки окон --- чтобы каждый терминал был в отдельном окне Windows; при этом надо установить опции для открытия каждого терминала в новом окне в _Settings > Startup > New instance behavior: Create a new window_.

* Для полнотекстового поиска по файлам, docx, pdf и т.п. смотри далее раздел [_RipGrep_](#ripgrep-и-rga).

* Привычную переменную _HOME_ можно задать в переменных среды окружения для пользователя выполнив:
  ```cmd
  setx HOME "%UserProfile%"
  ```

* Алиасы. Для каждой оболочки свои методы создания:
  + *\<TBD\>* https://stackoverflow.com/questions/17404165/how-to-run-a-command-on-command-prompt-startup-in-windows https://superuser.com/questions/1134368/create-permanent-doskey-in-windows-cmd
  + Для _PowerShell_: [Guide](https://www.sharepointdiary.com/2021/08/powershell-alias-beginners-guide.html) как задать постоянные [алиасы](https://learn.microsoft.com/ru-ru/powershell/module/microsoft.powershell.utility/set-alias) в [профиле](https://learn.microsoft.com/ru-ru/powershell/module/microsoft.powershell.core/about/about_profiles) PS.

* У WindowsTerminal есть возможность настроить глобальную горячую клавишу на вызов WindowsTerminal откуда угодно. Для этого в `settings.json` прописать команду [`"globalSummon"`](https://learn.microsoft.com/en-gb/windows/terminal/customize-settings/actions#global-summon) в разделе `"actions":`:
  ```json
  "actions": [
    {
      "command": {
        "action": "globalSummon"
      },
      "keys": "alt+t"
    }
  ]
  ```
* Для WindowsTerminal доступны некоторые [параметры запуска из командной строки](https://learn.microsoft.com/ru-ru/windows/terminal/command-line-arguments), например, можно настроить открывать отдельный WindowsTerminal (новое окно) на запуск какого-то конкретного приложения, со специально настроенным профилем, например, создать алиас `doskey vi=wt -d %CD% -p "wt-nvim" -- nvim $*` и профиль с именем _"wt-nvim"_ с командой `%SystemRoot%\System32\cmd.exe /c nvim`, тогда по команде `vi test-01.cpp` откроется новое окно с WindowsTerminal с открытым файлом _test-01.cpp_ в редакторе _nvim._

* [Список всех действий WindowsTerminal](https://learn.microsoft.com/ru-ru/windows/terminal/customize-settings/actions), любое из них можно настроить на желаемую комбинацию клавиш.



#### Использование WindowsTerminal

См. также главу [_Полезные консольные утилитки_](#полезные-консольные-утилитки).

*\<TBD\>*

[Возможности WindowsTerminal](https://learn.microsoft.com/ru-ru/windows/terminal/).

* `Ctrl-Shift-P` --- открыть _Command Palette_ --- панель действий
* `Ctrl+Shift+T` --- открыть новую вкладку с терминалом по умолчанию
* `Ctrl+Shift+N` --- открыть новое окно с терминалом по умолчанию
* `Ctrl+Shift+Space` --- открыть селектор открытия новой вкладки
* `Ctrl+Alt+1` --- переключиться на первую вкладку
* `Ctrl+Alt+2` --- переключиться на вторую вкладку
* `Ctrl+Shift+1` --- открыть новую вкладку с профилем 0
* `Ctrl+Shift+2` --- открыть новую вкладку с профилем 1


WindowsTerminal умеет открывать терминалы не только в табах, но и [панелях](https://learn.microsoft.com/ru-ru/windows/terminal/panes), т.е. в одном окне несколько терминалов, расположенных плиткой.

[Список всех действий WindowsTerminal](https://learn.microsoft.com/ru-ru/windows/terminal/customize-settings/actions), любое из них можно настроить на желаемую комбинацию клавиш.

_Links:_ [WT by MS](https://learn.microsoft.com/ru-ru/windows/terminal/), [WT actions](https://learn.microsoft.com/en-gb/windows/terminal/customize-settings/actions), [doskey](https://learn.microsoft.com/ru-ru/windows-server/administration/windows-commands/doskey), [Guide](https://freshman.tech/windows-terminal-guide/).

### Финальный уровень сложности

В принципе, на этом можно и остановиться, но для полноценной разработки/программирования рекомендуется установить и настроить нормальную командную оболочку (shell) [**Clink**](https://chrisant996.github.io/clink/).

В [_Приложении_ показана настройка Clink](#консольная-оболочка-clink-и-утилиты-busybox).

После **установки и настройки Clink** останется только настроить для него профиль в WindowsTerminal, который проще всего получить сдублировав профиль для _cmd.exe_, после чего, в новом профиле, в качестве запускаемой команды прописать:
```cmd
%SystemRoot%\System32\cmd.exe /k "clink inject"
```

Так же в Приложении есть краткая справка по [использованию оболочки **Clink**](#использование-clink).\
См. также главу [_Полезные консольные утилитки_](#полезные-консольные-утилитки).


### Немного о шрифтах

При постоянном использовании консольных приложений одним из ключевых факторов эргономики являются шрифты. Не стоит пренебрегать шрифтами, времени много не займёт, а удобство повысит.

Для консольных приложений используются моноширинные шрифты. Посмотреть наиболее популярные бесплатные шрифты можно на сайте <https://www.nerdfonts.com/font-downloads>.

Для улучшения читабельности длинных строк можно использовать _сжатые_ (_condensed_, _compressed_, _narrow_) шрифты, это шрифты, которые более высокие, чем широкие. Примеры сжатых шрифтов: [Iosevka](https://github.com/be5invis/Iosevka)([view](https://www.programmingfonts.org/#iosevka)), [D2CodingLigature](https://github.com/Joungkyun/font-d2coding)([view](https://www.programmingfonts.org/#d2coding)).

В последние годы в консольных программах стали широко использоваться шрифты с иконками, смайликами, и прочими стрелочками. Проект <https://www.nerdfonts.com/> добавляет набор иконок к любым шрифтам. При установке шрифтов, при прочих равных, следует выбирать версию _Nerd Font_, если есть в наличии.

Все, или почти все, шрифты можно установить через [_Scoop_](https://github.com/matthewjberger/scoop-nerd-fonts/tree/master/bucket). [Поиск шрифта](https://scoop.sh/#/apps?q=nerd+font), установка шрифта:
```sh
scoop bucket add nerd-fonts
scoop install nerd-fonts/Iosevka-NF-Mono
```

## Многокарманный буфер обмена

[**CopyQ**](https://github.com/hluk/CopyQ) --- многокарманный буфер обмена. _Note:_ хоть в Windows и есть встроенный многокарманный буфер, но он очищается при перезагрузке, поэтому его невозможно использовать как некую временную "записную книжку" с сохранёнными фрагментами текста.

_CopyQ_ поддерживает несколько списков хранения, позволяет исправлять (редактировать) хранимые фрагменты текста, поддерживает темы оформления, кроссплатформенный.

Установка:
```cmd
winget install --id=hluk.CopyQ -e
```

~~Для автозапуска _CopyQ_ при загрузке Windows, необходимо скопировать ссылку на CopyQ в папку автозапуска, для этого в меню _Start_ правой кнопкой по нему выбрать _Open file location_, скопировать ярлык, и _Paste_ его в папку автозапуска, открываемую по команде `shell:startup` в строке запуска `<Win+R>`.~~

Настройка:

* `<Win+V>` занят встроенным в Windows буфером обмена, поэтому, на вызов CopyQ можно назначить сочетание клавиш `<Alt+V>` в _Preferences > Shortcuts > Globals: Show/Hide main window_;
* в настройках _Preferences > History_ увеличить количество хранимых заметок до 10000;
* в настройках _Preferences > Items > Images_ увеличить максимальный хранимый размер изображений до 2560 на 1600;
* при копировании в буфер форматированного текста (rich text) из Word или html, форматирование сохраняется. Эту особенность можно отключить в _Preferences > Items > Text_. Или настроить _Paste as plain text_ в _Shortcuts_.

Еще есть многокарманный буфер [_Ditto_](https://ditto-cp.sourceforge.io/), если _CopyQ_ чем-то не устроит, [установка](https://winstall.app/apps/Ditto.Ditto).

## Системы виртуализации WSL и Docker

**WSL** требуется для программирования: для компиляции и отладки программ. **Docker** необходим для установки некоторых сложных приложений (_OpenFOAM_).

### WSL

[**WSL**](https://learn.microsoft.com/ru-ru/windows/wsl/setup/environment) --- Windows Subsystem for Linux, это встроенная в Windows система виртуализации, позволяющая запускать Linux приложения непосредственно в Windows.

Сначала установить [WSL2](https://learn.microsoft.com/ru-ru/windows/wsl/install), для этого в терминале (Admin) запустить:
```cmd
wsl --install
```

В процессе установки Ubuntu установить набор пакетов для программирования:
```sh
sudo apt update
sudo apt install aptitude mc bash-completion neovim wget curl \
         ca-certificates git build-essential gfortran libopenmpi-dev \
         mpi-default-bin libopenblas-dev libopenblas-openmp-dev \
         libhypre-dev liblapack-dev liblapack-doc libhdf5-mpi-dev \
         libscotch-dev petsc-dev libsuitesparse-dev libsuperlu-dev \
         libsuperlu-dist-dev fortran-language-server gdb \
         python3 python3-pip ripgrep fzf fd-find parallel
```

Методы запуска консоли WSL:

* самый лучший вариант, это запуск в отдельном профиле в _WindowsTerminal_^[сам автоматически настроится при установке WSL] (или в отдельном профиле в [_Cmder_](https://conemu.github.io/en/wsl.html#wsl-native)^[настраивается автоматически в _Cmder_ по _Setup Tasks > Add/refresh default tasks_]);
* запуск команды `wsl` прямо из запущенного термина Cmd/Clink/PowerShell/Far, который запущен в WT или Cmder;
* запускать `WSL` или `Ubuntu.exe` из меню _Start/Пуск_;

_Note:_ _Ubuntu.exe_ --- это alias --- Windows автоматически создаёт такие ссылки для каждой WSL системы для быстрого доступа/запуска.

_Note:_ установленные в WSL2 графические Linux приложения работают "из коробки".

#### WSL Manager

Существуют графические утилиты для управления WSL контейнерами, одна из них [**WSLManager**](https://github.com/bostrot/wsl2-distro-manager); [установка](https://winstall.app/apps/Bostrot.WSLManager):
```cmd
winget install --id=Bostrot.WSLManager -e
```

#### _Отступление_ про использование _WSL_: {.unnumbered .unlisted}

Аргументы _some commands_ после слова _wsl_ в команде `wsl some commands` будут запущены внутри WSL виртуалки: например, команда `wsl rg "some-phrase"` запустит Linux утилиту `rg`, которая, в данном случае, будет выполнять полнотекстовый поиск _"some-phrase"_ в текущей папке. Т.е. в любом терминале Windows можно выполнить команду Linux, в том числе для действий над своими файлами/данными лежащими на локальных дисках _C:_, _D:_ и т.п.

Аналогично, скомпилировать программу из исходного кода, с использованием библиотеки _OpenMPI_:\
`wsl mpif90 -g -o test test.f`\
Запустить скомпилированную параллельную программу в параллельном режиме:\
`wsl mpirun -n 4 ./test`\
Запустить отладку скомпилированной программы:\
`wsl gdb test`

В итоге, в Windows более не требуется сложная процедура установки компиляторов, библиотек, прописывания путей, и т.п. --- это всё делается в Linux, который лучше для этого приспособлен.

### Docker

[**Docker**](https://www.docker.com/products/docker-desktop/) --- это менеджер виртуальных машин; сам он не выполняет виртуальные машины, а только занимается организацией создания, хранения, и запуска машин с помощью других систем виртуализации, например, таких как WSL. Поэтому, [устанавливать Docker](https://learn.microsoft.com/ru-ru/windows/wsl/tutorials/wsl-containers) следует только после установки WSL.

[Установка](https://winstall.app/apps/Docker.DockerDesktop):
```cmd
winget install --id=Docker.DockerDesktop -e
```

Про установку и запуск виртуальных машин в Docker см. далее в [_Дополнительных материалах_](#управление-dockerом).

## ssh/PuTTY

В Windows для удалённого доступа по протоколу _ssh_ могут использоваться [**Putty**](https://www.chiark.greenend.org.uk/~sgtatham/putty/) и [**OpenSSH**](https://www.openssh.com/). Оба пакета выполняют один функционал. _OpenSSH_ запускается в окне консольного теминала WindowsTerminal/Cmder/Conemu, поэтому в нём доступны все клавиши навигации, настроенные [_шрифты_](#отступление-про-шрифты) и цветовая схема. У _Putty_ свой графический терминал с небольшим числом возможностей и настроек. В Windows выбор между _Putty_ и _OpenSSH_ определяется привычкой и удобством использования, по качеству ssh-соединения они одинаковы.

Документация по настройке ssh/Putty на Windows: [SSH-on-Windows](https://github.com/ScoopInstaller/Scoop/wiki/SSH-on-Windows), [Integrate-SSH-Agent-or-PuTTY-Agent](https://github.com/cmderdev/cmder/wiki/Integrate-SSH-Agent-or-PuTTY-Agent).

_Note:_ В Windows имеется встроенный _OpenSSH_, но из-за [ANSI несовместимости](https://github.com/Maximus5/ConEmu/issues/1625#issuecomment-402519869) его нельзя применять в терминалах Cmder/Conemu, поэтому потребуется ещё установить нормальный _OpenSSH._

Установить оба, и [_OpenSSH_](https://www.openssh.com/), и [_Putty_](https://www.chiark.greenend.org.uk/~sgtatham/putty/):
```cmd
scoop install openssh
winget install --id=PuTTY.PuTTY -e
```

Для настройки входа без пароля потребуется добавить свой публичный (*.pub*) ключик к файлу `~/.ssh/authorized_keys` на удалённом узле (хосте); далее рассмотрены оба варианта, и для _OpenSSH_ и для _Putty_.

### Вариант для OpenSSH соединения {.unlisted}

[Инструкция](https://www.ssh.com/academy/ssh/copy-id):

1. Посмотреть содержимое папки в домашней директории на Windows `%UserProfile%\.ssh` на наличие уже созданных ключей, если там есть пара файлов `id_SOMEPROTOCOL` и `id_SOMEPROTOCOL.pub`, то ключи уже созданы и перейти к следующему шагу, иначе создать их командой:
   ```cmd
   ssh-keygen
   ```
   понажимать _Enter_, и ключи готовы.

2. Скопировать ключ на удалённый хост:
   ```cmd
   ssh-copy-id user@hostname
   ```

### Вариант для Putty соединения {.unlisted}

[Инструкция](https://putty.org.ru/articles/putty-ssh-key-auth) тут посложнее:

1. Открыть из меню Start _PuTTYgen_, сгенерировать ключ, сохранить обе части --- public/private.

2. Выделить открытую часть и скопировать в буфер обмена, чтобы добавить в файл `.ssh/authorized_keys` на Linux, для чего зайти на Linux через Putty, и выполнить:
   ```sh
   cd ~/.ssh
   vi authorized_keys
   ```
   Далее процесс добавления ключа из буфера обмена в открытый в `vi` файл: набрать на клавиатуре команду:
   ```default
   Go<Shift+Insert><Esc>:wq
   ```
   здесь `<Shift+Insert>` и `<Esc>` --- это клавиатурные комбинации, а не строчки которые вводить.\
   (_Note:_ паблик ключ должен иметь форму одной строки, если это не так, то лишние переводы строки необходимо стереть: в `vi` это делается командой `Shift+J`, которая объединяет текущую и следующую строки; этой командой можно воспользоваться после `<Esc>`, перед `:wq`.)

   Поправить права доступа (на всякий случай):
   ```sh
   chmod 600 authorized_keys
   ```
   Можно выходить из сессии: `exit` == `Ctrl+D`.

3. Теперь добавить ключ в Putty для использования: запустить из Start _Pageant_. Правой кнопкой мышки в трее на иконке _Pageant_ кликнуть и указать _Add key_, выбрать сохранённый приватный ключ _.ppk_. Чтобы вход по ключам всегда срабатывал, потребуется настроить автозапуск _Pageant_: скопировать ссылку на _Pageant_ в папку автозапуска, для этого в меню Start правой кнопкой по нему выбрать _Open file location_, скопировать ярлык, и _Paste_ его в папку автозапуска, открываемую по `shell:startup` в `<Win+R>`.

### Конвертация ключей _Putty_ в формат _ssh_ {.unlisted}

Формат хранения ключей у Putty отличается от формата _ssh_. Для того, чтобы сохранить в нормальном формате, у Putty, в утилите генерации ключей _C:\\Program Files\\PuTTY\\puttygen.exe_, есть менюшка _Conversions > Export OpenSSH key (force new file format)_, которая сохраняет приватный ключ в формате _ssh_ (сохранять в файл без расширения, в `id_rsa`). Формат _.pub_ ключа идентичен нормальному, его конвертировать не потребуется. Эти два файла: `id_rsa` и `id_rsa.pub`, скопировать в папку `%UserProfile%\.ssh`, после чего `ssh` начнёт их видеть.

## X-server

Установленный _WSL_ несёт в себе "нативный" _X-server_, он работает, его можно использовать, но его производительность заметно ниже, чем у [**VcXsrv**](https://repology.org/project/vcxsrv/versions). Поэтому, установить VcXsrv:
```cmd
sudo choco install -y vcxsrv
```

_Note:_ VcXsrv запускается командой `XLaunch` из меню _Пуск_.

_Note:_ При возникновении ошибок _X-Authority_ при соединении, можно попробовать отключить контроль безопасности: для этого при запуске _XLaunch (VcXsrv)_ поставить галочку "Disable Access Control", это приведёт к разрешению на запуск графических приложений с _любого_ удалённого узла.

### OpenSSH {.unlisted}

Для создания ssh-соединения в _OpenSSH_ выполнить в _cmd_/_Clink_/_Far_:
```cmd
set DISPLAY=127.0.0.1:0.0
ssh -X somename@somehost
```
тогда проброс (_Forwarding_) протокола *X11*  заработает ([Guide](https://x410.dev/cookbook/built-in-ssh-x11-forwarding-in-powershell-or-windows-command-prompt/)).

_Ненужные пояснения:_

* Здесь *127.0.0.1:0.0* --- это IP-адрес *localhost*'а, на котором наш запущенный локальный X-сервер ожидает данных, и указание на номер дисплея (*0.0*) X-сервера. Здесь применяется явный IP-адрес, а не имя *localhost*, потому что последний может быть и IPv6.
* Опция `-X` (или `-Y`) указывает утилите `ssh` на создание X-Forwarding. `-X` --- это вариант опции со включёнными ограничениями безопасности; `-Y` означает, что X11 приложение будет иметь полный доступ к отображаемому на локальном мониторе, этого варианта следует избегать, или применять только для доверенных удалённых хостов и доверенных X11 приложений.

### PuTTY {.unlisted}

При создании ssh-соединения через Putty, для возможности запуска графических приложений по протоколу *X11*, в настройках Putty необходимо устанавливать галочку _X-Forwarding_ (эквивалентно опции `-X`/`-Y` у `ssh`).

### Тест {.unlisted}

После настройки _X_ сервера проверить его работоспособность можно парочкой утилит: `xclock` --- простые часы с циферблатом, и `glxgears` --- OpenGL программка из пакета _mesa-utils_.

> _Отступление:_ Когда графическое приложение отрисовывается по X11 протоколу, оно отправляет *"команды отрисовки"* на локальный X-сервер, т.е отправляет не картинку, а инструкции как эту картинку рисовать. В общем случае, эти X11 инструкции имеют полный доступ к экрану и могут считывать всё его содержимое. Поэтому, для безопасности, в X-серверах, по умолчанию, включён режим *"X11 SECURITY extension"*, когда может применяться только ограниченный набор X11 команд, которые не имеют доступа к экрану. Но, некоторые X11 приложения, для полноценной работы, не могут ограничиться таким урезанным набором X11 команд, и, для них была введена опция `-Y`, отключающая ограничения *"X11 SECURITY extension"*. Эту опцию следует применять только в случае, если *необходимое* приложение, которому вы доверяете, без неё не работает.

## Удалённый рабочий стол

Помимо привычного _RDP_ --- Remote Desktop Protocol, существуют несколько инструментов для удалённого подсоединения, с более удобным и широким функционалом, которые могут проходить через интернет.

*\<TBD\>*

Один из них, это _кроссплатформенный_ [**RustDesk**](https://rustdesk.com/), позволяющий подсоединяться к рабочему столу компьютера в локальной сети. Также, через выделенный сервер, возможен коннект к _любому_ компьютеру через интернет, без необходимости VPN. Установка:
```cmd
winget install --id=RustDesk.RustDesk -e
```


## OpenVPN


[**OpenVPN**](https://en.wikipedia.org/wiki/OpenVPN).

```cmd
winget install --id=OpenVPNTechnologies.OpenVPN -e
```

_Настройка:_ Проще всего скопировать ключи прямо вместе с их папкой, в "_C:\\Program Files\\OpenVPN\\config_". OpenVPN увидит их (после перезапуска?) и будет показывать в виде отдельной папки конфигурации (появится возможность выбирать из нескольких ключей).

> _Warning:_ Ни в коем случае не пытаться загрузить ключи через меню интерфейса _Import > Import File..._, потому что в этом случае будет скопирован только один файл из трёх!

#### Legacy OpenVPN {.unnumbered .unlisted}

OpenVPN версии 2.6.xy не работает с более старыми ключами, т.к. в них [изменились некоторые параметры](https://community.openvpn.net/openvpn/wiki/DeprecatedOptions) (при использовании ключей в устаревшем формате появляется запрос на ввод пароля).

Поэтому, либо скачать предыдущую версию 2.5.xy (2.5.10) с сайта <https://openvpn.net/community-downloads/> и, после установки, зафиксировать эту версию командой\
`winget pin add OpenVPNTechnologies.OpenVPN`, либо ~~отредактировать _.ovpn_ файл~~ скачать ключики заново --- они будут уже в новом формате.


{{< pagebreak >}}

# **_Этап 2: Установка и настройка иногда нужных программ_** {.unnumbered}

# Настройка среды для программирования

В руководстве рассматривается вариант настройки универсальной среды разработки [**VSCode**](https://code.visualstudio.com/) в Windows, который будет использовать инструменты Linux для компиляции, запуска и отладки программ. Для этого в VSCode используются плагины [WSL](https://code.visualstudio.com/docs/remote/wsl) и [Remote Development](https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.vscode-remote-extensionpack), которые позволяют запускать компиляторы и отладчики, как локально (_WSL_), так и удалённо по _ssh_. _Note:_ Также существует вариант запуска процесса разработки внутри виртуальных машин в [Docker](https://docs.docker.com/desktop/features/wsl/use-wsl/#develop-with-docker-and-wsl-2).

Сначала установить _WSL2_ и _Docker_ --- см. выше.

## VSCode

[Docs](https://code.visualstudio.com/docs),
[Getting started](https://code.visualstudio.com/docs/getstarted/getting-started),
[Keybindings](https://code.visualstudio.com/docs/getstarted/keybindings),
[Keybindings.pdf](https://code.visualstudio.com/shortcuts/keyboard-shortcuts-windows.pdf).


Если VSCode ещё не установлен, то установить:
```cmd
winget install --id=Microsoft.VisualStudioCode -e
```

Для запуска компилятов и т.п. в Windows используется префикс `wsl`:
```cmd
wsl gfortran -g -o test test.f
wsl gdb test
```

VSCode [умеет](https://learn.microsoft.com/ru-ru/windows/wsl/tutorials/wsl-vscode) так запускать компиляторы и отладчики при помощи расширения [WSL](https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-wsl).

Для начала работы, после установки расширения _WSL_, в Cmd/PS перейти в папку с проектом или исходным кодом программы, и запустить команду:
```cmd
wsl code .
```

`code` --- это название исполняемого файла VSCode, она так называется. В результате выполнения команды запустится VSCode с открытой текущей папкой (`.`).

_Note_: при таком опосредованном выполнении в WSL, VSCode расширения (extensions) будут устанавливаться в раздел плагинов _WSL_ --- в нижний список установленных расширений. Т.е. в VSCode будет два набора расширений, и, возможно, какие-то расширения будут установлены и там и там, например [Python](https://marketplace.visualstudio.com/items?itemName=ms-python.python), который можно использовать как в WSL, так и локально с помощью нативного _python_.

Расширение [WSL](https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-wsl) запускает компилятор и пр. локально, непосредственно на компьютере. Существует вариант удалённой работы через _ssh_ по сети --- на кластер или внутрь виртуальных машин --- делается это с помощью расширения [Remote Development](https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.vscode-remote-extensionpack). Это расширение позволяет проводить удалённую работу/отладку с любого компьютера, в том числе через интернет, причём все настройки сохраняются на стороне удалённого сервера/виртуалки (в папке проекта _.vscode_), и проекты будут настроены одинаково с любого удалённого места доступа.

_Note:_ Профессиональные разработчики в своей работе применяют [Docker](https://marketplace.visualstudio.com/items?itemName=ms-azuretools.vscode-docker), который позволяет для каждого запуска отладки создавать новый, эталонно настроенный контейнер (виртуалку), и уже с ним работать. Эта технология позволяет:\

  * иметь разные версии компиляторов, библиотек и настроек для отладки разных приложений;
  * проводить разработку и отладку на гарантированно одинаковом наборе исходных данных, без необходимости после каждого запуска вручную очищать и копировать данные;
  * также, эта технология позволяет настроить *Continuous Integration (CI)* --- сервис Непрерывной Интеграции, запускающий набор тестов для каждого изменения (commit) внесённого в исходный код.

## C/C++

[Расширение C/C++](https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools) для VSCode должно работать "из коробки".

Для удобства необходимо [создать git репозиторий](#система-контроля-версий-git) в папке проекта, тогда VSCode автоматически найдёт файлы, которые следует скомпилировать и отлаживать.

### Отладка в Windows {.unnumbered .unlisted}


```sh
cd project
wsl code .
```

*\<TBD\>*

Отладка в Windows не должна отличаться от отладки в Linux, см. следующий пункт.

### Отладка в Linux {.unnumbered .unlisted}

<https://code.visualstudio.com/docs/editor/debugging>

```sh
cd project
code .
```

#### Простой вариант {.unnumbered .unlisted}

Для запуска отладки надо ткнуть _Breakpoint_ в коде (кликнуть левее номеров строк), и запустить из меню _Run > Start debugging_ (`F5`). VSCode скомпилирует файлы и запустит отладку.

#### Вариант посложнее {.unnumbered .unlisted}

Для отладки в каких-то более сложных случаях, например, когда требуется передать аргументы командной строки, потребуется создать:

а) Build configuration, _tasks.json_.

Создать конфигурацию: _Ctrl+Shift+P_: _Tasks: Configure Default Build Task > gcc debug_, откроется _tasks.json_, его просто сохранить.
Скомпилировать: _Ctrl+Shift+P_: _Tasks: Run Build Task_ (_Ctrl+Shift+B_)

Конфигурация по умолчанию:
```json
{
    "tasks": [
        {
            "type": "cppbuild",
            "label": "C/C++: gcc build active file",
            "command": "/usr/bin/gcc",
            "args": [
                "-fdiagnostics-color=always",
                "-g",
                "${file}",
                "-o",
                "${fileDirname}/${fileBasenameNoExtension}"
            ],
            "options": {
                "cwd": "${fileDirname}"
            },
            "problemMatcher": [
                "$gcc"
            ],
            "group": {
                "kind": "build",
                "isDefault": true
            },
            "detail": "Task generated by Debugger."
        }
    ],
    "version": "2.0.0"
}
```

б) сгенерировать и отредактировать файл настроек запуска отладки проекта [**_launch.json_**](https://code.visualstudio.com/docs/cpp/launch-json-reference): в панели слева открыть панель отладки (жучок с треугольником), нажать ссылку _create a launch.json file_,  из [выпадающего меню](https://code.visualstudio.com/docs/editor/debugging#_add-a-new-configuration) выбрать _Launch C++_, и отредактировать только что созданный _launch.json_. Изменить поля для имени и аргументов, например:
```json
"program": "${workspaceFolder}/test",
"args": ["mon-coordinates.csv", "1", "13"],
```

```json
{
    // https://code.visualstudio.com/docs/editor/debugging#_launch-configurations
    "version": "0.2.0",
    "configurations": [
        {
            "name": "(gdb) Launch",
            "type": "cppdbg",
            "request": "launch",
            "program": "${workspaceFolder}/test",
            "args": ["mon-coordinates.csv", "1", "13"],
            "stopAtEntry": false,
            "cwd": "${workspaceFolder}",
            "environment": [],
            "externalConsole": false,
            "MIMode": "gdb",
            "setupCommands": [
                {
                    "description": "Enable pretty-printing for gdb",
                    "text": "-enable-pretty-printing",
                    "ignoreFailures": true
                },
                {
                    "description": "Set Disassembly Flavor to Intel",
                    "text": "-gdb-set disassembly-flavor intel",
                    "ignoreFailures": true
                }
            ]
        }
    ]
}
```

#### _Notes_ {.unnumbered .unlisted}

Для просмотра векторов в окошке _Watch_ нажать `+` и набрать `argv, 4`, где _4_ это длина просматриваемого участка вектора `argv`.

## Python

На Windows можно установить нативный компилятор Python и его библиотеки, без использования WSL.

У Python есть несколько менеджеров окружений, которые используются для разделения установленных пакетов на независимые "песочницы", с тем, чтобы было возможно установить пакеты, которые имеют зависимости, конфликтующие с зависимостями других пакетов. Помимо встроенного в Python менеджера [**_pip_**](https://pypi.org/project/pip/) существует простой и удобный [**_pipx_**](https://pipx.pypa.io/stable/). На практике, при установке широкоизвестных библиотек, лучше использовать стандартный метод `pip install --upgrade some-python-library`. Но если устанавливается Python-программа, особенно с большим числом зависимостей, то её лучше установить в отдельное окружение: `pipx install some-python-app`.

Установка _python_ (_pip_ идёт в комплекте):
```cmd
scoop install python
```

После установки в консоли было выведено сообщение о возможности регистрации _python_ для других приложений, и для этого предлагается выполнить reg-файл\
`%UserProfile%\scoop\apps\python\current\install-pep-514.reg`, что стоит сделать.

_Note:_ после установки, для того, чтобы _.py_ файлы стали запускаемыми (как _.exe_), необходимо ассоциировать их с\
`%UserProfile%\scoop\apps\python\current\python.exe`, либо просто запустив и выбрав, либо через меню _Choose a default app for each type of file_ в _Пуск_.

_Note:_ после установки Python, чтобы python-программы с расширением _.py_ можно было запускать без добавки расширения (как это не обязательно _.exe_), необходимо, чтобы расширение _.py_ [присутствовало](https://docs.python.org/3/faq/windows.html#id3) в переменной окружения _PATHEXT_.


Установка _pipx_:
```cmd
python -m pip install --upgrade pipx
pipx ensurepath
```

_Note:_ после установки какой-либо python-программы с помощью _pip_ или _pipx_, она будет в путях. Но, вполне возможно, что это будет python-скрипт без какого-либо расширения, ни _.exe_, ни _.py_ (как на Linux). В таком случае необходимо сделать _.exe_ ссылку на этот скрипт. Например, после установки `python -m pip install --upgrade eg`, создать ссылку: `scoop shim add eg python.exe -- -m eg`, здесь на ссылку `eg.exe` создаётся ассоциация `python.exe -m eg`, которая будет работать в Windows.

Списки установленных пакетов библиотек и python-программ: `pip list`, `pipx list`.

Установить математические и HPC библиотеки:
```cmd
python -m pip install --upgrade numpy
python -m pip install --upgrade plotly
python -m pip install --upgrade numba
python -m pip install --upgrade mpi4py
python -m pip install --upgrade jupyterlab
winget install --id=Microsoft.msmpisdk -e
winget install --id=Microsoft.msmpi -e
```

_Note:_ Здесь в списке присутствует библиотека [**numba**](https://github.com/numba/numba), это _JIT_^[Just-In-Time] компилятор Python, применяемый для высокопроизводительных вычислений (HPC). С его помощью можно добиться скорости выполнения Python программ наравне с C/C++ или Fortran. [Применение](https://numba.readthedocs.io/en/stable/user/5minguide.html) этой библиотеки совершенно тривиально: импортировать `from numba import jit` и добавить `@jit` перед определением своих функций `def ...`.

Для разработки на Python есть несколько вариантов IDE: [VSCode](https://marketplace.visualstudio.com/items?itemName=ms-python.python), [Spyder](https://www.spyder-ide.org/), [Positron](https://positron.posit.co/), проприетарный [PyCharm](https://www.jetbrains.com/pycharm/).

### Python в VSCode {.unnumbered .unlisted}

[VSCode](https://code.visualstudio.com/) рекомендуется как универсальная среда разработки, где освоив работу на каком-либо языке программирования, разработка на других языках уже не будет представлять сложности. Python в VSCode [использовать](https://code.visualstudio.com/docs/languages/python) [не сложно](https://marketplace.visualstudio.com/items?itemName=ms-python.python).
```cmd
scoop install extras/vscode
```

Расширение Python для VSCode позволяет выполнять участки кода по `Shift+Enter`. Также можно выполнять построчную отладку по _Debug_, _Run_, _NextLine_, _EnterInto_, и т.д.

### Python в Spyder {.unnumbered .unlisted}

В [**Spyder**](https://docs.spyder-ide.org/current/quickstart.html) всё настроено для Python "из коробки". Основной упор сделан на _Data Science_: обработка данных на Python, построение графиков, статистика. По стилю работы похож на MatLab. При первом запуске проводится краткий обучающий тур основам использования.
```cmd
winget install --id=Spyder.Spyder -e
```

_Note:_ При наличии HiDPI экрана в настройках для этого есть опция _Tools > Preferences > Application: Interface > Enable auto high DPI scaling_.

### Python в Positron {.unnumbered .unlisted}

Так же для _Data Science_ стоит попробовать [**Positron**](https://positron.posit.co/start.html). Это VSCode, где встроили набор плагинов для обработки данных на Python/R и проч. По стилю работы очень похож на VSCode (что подкупает ненужностью изучения чего-то непохожего), но это пока проект в beta стадии, могут встречаться ошибки.
```cmd
python -m pip install --upgrade ipykernel
scoop install extras/positron
```

### Блокноты на Python

Для создания [**_Интерактивных блокнотов_**](https://ru.wikipedia.org/wiki/Интерактивный_блокнот) (*журналов*) на Python следует предпочесть расширение [**Jupytext**](https://marketplace.visualstudio.com/items?itemName=donjayamanne.vscode-jupytext) (вместо [_Jupyter_](https://en.wikipedia.org/wiki/Project_Jupyter)), сохранённые файлы которого имеют нормальный **_.py_** формат со [специально оформленными комментариями](https://jupytext.readthedocs.io/en/latest/formats-scripts.html#the-percent-format), а не какой-то непонятный _JSON_.

*\<TBD\>* Подробнее об [интерактивных блокнотах](https://ru.wikipedia.org/wiki/Интерактивный_блокнот), [реактивном программировании](https://en.wikipedia.org/wiki/Reactive_programming).

## Fortran

*CHECKME:* *\<TBD\>*

```cmd
cd my-cool-fortran-project
wsl code .
```

Установить расширение [Modern Fortran](https://marketplace.visualstudio.com/items?itemName=fortran-lang.linter-gfortran), переключиться (Switch) на _Pre-Release_ версию расширения.

Если подсветка не заработала, то [разрешить](https://fortran-lang.discourse.group/t/modern-fortran-configuration-in-vscode/7055/7) в настройках _fortls_ (должен быть уже установлен _fortran-language-server_ в _WSL_).

Для компиляции потребуется файл настроек задач `task.json`:

Создать файл _tasks.json_ для настройки компиляции: открыть командную палитру `<Ctrl+Shift+P>`, ввести _Tasks: Configure Task_, выбрать _Create tasks.json file from template_, выбрать _Others_, отредактировать на:
```json
{
  // https://code.visualstudio.com/docs/editor/tasks#_custom-tasks
  "version": "2.0.0",
  "tasks": [
    {
      "label": "build",
      "type": "shell",
      "command": "gfortran",
      "args": [
        "-o",
        "${workspaceFolder}/program",
        "${file}"
      ],
      "group": {
        "kind": "build",
        "isDefault": true
      },
      "problemMatcher": ["$gcc"],
      "detail": "Generated task by VSCode"
    }
  ]
}
```

Для отладки потребуется создать/отредактировать файл [`launch.json`](https://github.com/fortran-lang/vscode-fortran-support?tab=readme-ov-file#debugging): открыть командную палитру `<Ctrl-Shift-P>`, _Debug_, _Edit launch.json_:
```json
{
  // https://code.visualstudio.com/docs/editor/debugging#_launch-configurations
  "version": "0.2.0",
  "configurations": [
    {
      "name": "(gdb) Fortran",
      "type": "cppdbg",
      "request": "launch",
      "program": "${workspaceFolder}/a.out",
      "args": [], // Possible input args for a.out
      "stopAtEntry": false,
      "cwd": "${workspaceFolder}",
      "environment": [],
      "externalConsole": false,
      "MIMode": "gdb",
      "setupCommands": [
        {
          "description": "Enable pretty-printing for gdb",
          "text": "-enable-pretty-printing",
          "ignoreFailures": true,
        },
      ],
    },
  ],
}
```

## Julia

[Установить](https://modernjuliaworkflows.org/writing/#installation) [**Julia**](https://julialang.org/):
```cmd
winget install --id=Julialang.Juliaup -e
juliaup add lts
julia
```

```julia
] add Revise, OhMyREPL, About, Unitful, Roots,
      DataStructures, Plots, Chairmarks, Debugger
```

Настроить `%UserProfile%\.julia\config\startup.jl`:
```julia
atreplinit() do repl
    @eval using OhMyREPL
    @eval using Unitful
    @eval using LinearAlgebra
    @eval using Chairmarks
    @eval using Debugger
    @eval using DataStructures
    @eval using About
    @eval using Revise
end
```

Установить [расширение Julia](https://code.visualstudio.com/docs/languages/julia) для VSCode ([пример установки](https://docs.sciml.ai/Overview/stable/getting_started/installation/#Optional-Step-1.5:-Get-VS-Code-Setup-with-the-Julia-Extension)).

После установки создать новый `test1.jl` файл, набрать в нём `1+1`, и нажать `Ctrl+Enter`, должно появиться всплывающее сообщение с ответом `2`, по `Esc` пропадёт; в открывшемся терминале также должен появиться ответ `2` (при первом запуске, или после обновления, период ожидания до ответа может быть продолжительным).

## Система контроля версий Git

*\<TBD\>*

\+ <https://github.com/>

## Полезные консольные утилитки

### _TL;DR --- Too Long; Didn't Read_

[**tldr**](https://github.com/tldr-pages/tldr) --- <https://tldr.sh/>.

Набор небольших справок по командам Windows, Linux, и т.д., по страничке буквально. В ней более 5000 справок, и, скорее всего, есть справки по всем командам, которые упоминаются в этом руководстве.

[Установка](https://scoop.sh/#/apps?o=true&q=tldr) (_Note:_ программа называется _tldr_, а пакет называется _tlrc_):
```cmd
scoop install tlrc
tldr --gen-config > %UserProfile%\AppData\Roaming\tlrc\config.toml
```
После отредактировать в конфиге `%UserProfile%\AppData\Roaming\tlrc\config.toml` в секции `[cache]` опцию `languages = ['ru','en']`, чтобы, по возможности, были справки на русском языке.

_Note:_ при первом запуске скачивает с инета архив со справками и распаковывает, занимает меньше минуты.

Использование:
```cmd
tldr robocopy
```


### robocopy

Встроенная утилита Windows для копирования файлов и папок с сохранением прав и времени создания. Применяется командой:

```cmd
robocopy d:some-dir e:some-another-dir /E /DCOPY:T
```

_"some-dir"_ будет скопирована в _"some-another-dir"_, получив в результате _"some-another-dir\\some-dir"_.


### fd --- поиск файлов

Установка:
```cmd
scoop install fd
```

#### Использование {.unnumbered .unlisted}

Утилита [`fd`](https://github.com/sharkdp/fd#how-to-use) в качестве шаблона поиска файлов использует [регулярные выражения](https://docs.rs/regex/latest/regex/#syntax) (по умолчанию), поэтому вместо классического шаблона `find -iname '*PATTERN*'` следует использовать ~~банальный~~ удобный:
```cmd
fd PATTERN
```
то есть для поиска курсовой набрать: `fd курсов`, или, если не нашлось, может так поможет: `fd kursov`.

`fd` считает свой шаблон в режиме _ignorecase_, если только в шаблоне нет заглавных букв, иначе шаблон _casesensitive_. Опция `-i` задаёт режим _ignorecase_.

Для поиска по привычным шаблонам со звёздочкой (`*`) применяется опция `-g`/`--glob`:
```cmd
fd --glob "task*.py"
fd -g "task*.{h,c,c++,cpp}" Projects
```
Эта же опция применяется для поиска по _точному имени_.

Поиск файлов по расширению:
```cmd
fd --extension docx
fd -e docx
```

Включить в поиск скрытые (системные) папки и файлы:
```cmd
fd --hidden -g "*.conf" %UserProfile%
```

Поиск с одновременным выполнением какой-либо команды над найденным файлом:
```cmd
fd -e doc %HOME% --exec soffice -convert-to docx {}
```
```cmd
fd --hidden "\.vhdx$" C:\ --exec ls -l {}
```

Опция `-t`, `--type` позволяет искать отдельно папки, файлы, и т.д., по типу: `f`/`file`, `d`/`directory`, `l`/`symlink`, `x`/`executable`, `e`/`empty`, например, найти все _git_ репозитории на диске _C:_ :
```cmd
fd --hidden -g "\.git" C:\ -t d
```

_Note:_ `fd` в поиске учитывает спецификации настроек проектов, _git_, и прочего; то есть, если в `.gitignore` указаны файлы или папки, то `fd` пропустит их, даже если они удовлетворяют критериям поиска. Для обхода есть опция `-I`, `--no-ignore`.


### ripgrep и rga

[**ripgrep**](https://github.com/BurntSushi/ripgrep) (`rg`)\
Быстрый поиск по текстовым файлам.

[**rga**](https://github.com/phiresky/ripgrep-all)\
_rg all_ --- поиск по документам: pdf, docx (но не doc), html, ipynb, внутри архивов. `rga` внутри использует `rg` для поиска по распакованному содержимому документов, и, все опции `rg`, это и опции `rga`.

```cmd
scoop install ripgrep
scoop install pandoc
scoop install poppler
scoop install rga
```

Настройка: создать переменную окружения `RIPGREP_CONFIG_PATH` указывающую на файл `%HOME%\.config\ripgreprc`; создать этот файл с конфигурацией:
```cmd
--smart-case
--auto-hybrid-regex
--glob=!*~
--glob=!*~?
# https://github.com/BurntSushi/ripgrep/blob/master/FAQ.md#how-do-i-configure-ripgreps-colors
--colors=path:fg:blue
```

С такой конфигурацией, если в шаблоне нет заглавных букв, то `rg` будет считать шаблон _ignorecase_, иначе шаблон _casesensitive_. Строчка конфигурации _\-\-auto-hybrid-regex_ указывает применять разные библиотеки _regex_ в зависимости от сложности шаблона --- для простых шаблонов это значительно ускоряет поиск. Применённая опция `--glob=!*~` указывает пропускать (`!`) файлы оканчивающиеся на `~`.

#### Использование {.unnumbered .unlisted}

Как и `fd`, `rg` производит поиск по шаблонам в форме [регулярных выражений](https://docs.rs/regex/1.11.1/regex/#syntax), поэтому не нужны какие-либо звёздочки, а надо прямо набирать:
```cmd
rg sometext
```

Поиск по файлам определённого типа опцией `g`/`--glob`:
```cmd
rg --glob "*.py" задача
rg -g "*.py" -g "*.ipynb" задача
rg задача -g "*.{c,c++,h}"
```
```cmd
rga -g "*.{docx,pdf}" отчет
```

_Note:_ Для `rga` тип документов для поиска можно задать выбором адаптера (просмотрщика) с помощью опций таких как `rga --rga-adapters=pandoc,zip`, но, это достаточно широкие классы документов, поэтому лучше задавать по расширению, как было сделано выше. Адаптеры `rga`:

* _pandoc_ отвечает за: .epub, .odt, .docx, .fb2, .ipynb, .html, .htm;
* _poppler_ за .pdf;
* _decompress_: .als, .bz2, .gz, .tbz, .tbz2, .tgz, .xz, .zst;
* _tar_: tar;
* _zip_: .zip, .jar


Поиск по целым словам опцией `-w`/`--word-regexp`:
```cmd
rg -w argparse -g "*.py"
```

Вывести только имена файлов содержащих искомое --- опция `-l`/`--files-with-matches`.

Вывести контекст найденного, это опции `A`/`B`/`C` --- _After_, _Before_, _Context_. Следующее выражение выводит полную историю команд, а затем `rg` ищет команды над _init.lua_ и выводит не только саму команду, но и ближайшие 5. Это выражение, так же, показывает особенность регулярных выражений --- в них точка обозначает любой символ, а вот для поиска самой точки её необходимо экранировать:
```cmd
history | rg -C5 "init\.lua"
```

Опять же, аналогично `fd`, поиск по скрытым файлам с опцией `--hidden`.


### parallel

[GNU **parallel**](https://www.gnu.org/software/parallel/), это утилита, которая: запускает в параллель несколько задач; отслеживает их завершение, чтобы запустить следующую в очереди задачу; отслеживает вывод на экран, чтобы информация не выводилась вперемешку; может разбивать большие файлы для обработки в параллель по кусочкам; и многое другое. [Википедиа](https://ru.wikipedia.org/wiki/GNU_parallel), [Tutorial](https://www.gnu.org/software/parallel/parallel_tutorial.html).

В Windows может использоваться `parallel` из _WSL_:

```cmd
wsl parallel -j4 "cmd.exe /c magick convert {} -resize 1920x1080  resized_{}" ::: *.jpg
```

```cmd
ls -1 *.jpg | wsl parallel -j4 "cmd.exe /c magick convert {} -resize 1920x1080 {.}.png"
```

В этих командах утилита обработки изображений _magick_ (из пакета _ImageMagick_) запускается в параллель. Здесь:

* `-j4` определяет число параллельно запускаемых задач;
* `:::` отделяет запускаемую команду от аргументов для _parallel_;
* `{}` --- [строка замены](https://www.gnu.org/software/parallel/parallel.html#options), на место которой будет подставлен аргумент для распараллеливаемой команды;
* `{.}` --- строка замены, в которой будет удалено расширение файла;
* используется `cmd.exe /c` чтобы не пришлось прописывать полные пути до запускаемой команды, так как `wsl` не знает путей _PATH_ Windows;

_Note:_ Установка _parallel_ в _WSL_: `wsl sudo apt install parallel`.


### time

**time** --- утилита из мира Linux, позволяющая измерить время выполнения программы.\
Установка: `scoop install time`.

Использование вполне обычное, только необходимо использовать команду `timecmd`, т.к. имя _time_ занято --- это встроенная команда Windows с другим функционалом:
```cmd
timecmd make all
```

_Note:_ При использовании современной темы оформления оболочки (shell) подобная утилита не требуется, так как сам терминал пишет затраченное время.

### top

Утилиты схожие с `top`: `btop`, `wttop`
```cmd
scoop install btop
scoop install wttop
```

### ccat

Утилита `cat`, которая выводит содержимое файлов с подсветкой, как в приличных редакторах:
```cmd
scoop install ccat
```


### mc --- Midnight Commander

Классика на Windows тоже работает, и умеет _Shell link..._.
```cmd
scoop install extras/mc
```

_Note:_ Сменить диск: `Alt+D`

_Note:_ Терминал в `mc` по `Ctrl+O` нормально не работает.


### Остальные Linux утилиты

Большое количество стандартных Linux консольных утилит входит в пакет _BusyBox_.

_Note:_ [**BusyBox**](https://frippery.org/busybox/) --- это набор Linux [_команд_](https://www.busybox.net/downloads/BusyBox.html#commands), скомпилированных для Windows, которые поддерживают [wildcard](https://frippery.org/busybox/globbing.html) [globbing](https://stackoverflow.com/questions/72434739/globbing-patterns-in-windows-command-prompt-powershell) как в Linux.

Установка:
```cmd
scoop install busybox
```

Общие опции:

* `-h` --- [h]uman, выводить размеры в _Kb (KiB)_, _Mb (MiB)_, и т.д., а не в байтах;

_**Note**:_ `ls` из состава BusyBox не умеет показывать файлы с русскими буквами в имени файла. Поэтому, её следует заменить на утилиту `ls` из состава приложения `git`:
```cmd
scoop shim add ls %UserProfile%\scoop\apps\git\current\usr\bin\ls.exe
```
Пока не пофиксят этот [баг](https://github.com/rmyorston/busybox-w32/issues/17), данную процедуру придётся повторять после каждого обновления BusyBox, благо такие обновления могут быть проведены только вручную командой `scoop update --all`.


#### BusyBox команды


[_\[_](https://www.opennet.ru/man.shtml?topic=test)
[_\[\[_](https://www.opennet.ru/man.shtml?topic=test&category=1&russian=5)
[_ar_](https://frippery.org/busybox/BusyBox.html#ar)
[_arch_](https://frippery.org/busybox/BusyBox.html#arch)
[_ascii_](https://frippery.org/busybox/BusyBox.html#ascii)
[_ash_](https://frippery.org/busybox/BusyBox.html#ash)
[_awk_](https://frippery.org/busybox/BusyBox.html#awk)
[_base32_](https://frippery.org/busybox/BusyBox.html#base32)
[_base64_](https://frippery.org/busybox/BusyBox.html#base64)
[_basename_](https://frippery.org/busybox/BusyBox.html#basename)
[_bash_](https://frippery.org/busybox/BusyBox.html#bash)
[_bc_](https://frippery.org/busybox/BusyBox.html#bc)
[_bunzip2_](https://frippery.org/busybox/BusyBox.html#bunzip2)
[_busybox_](https://frippery.org/busybox/BusyBox.html#busybox)
[_bzcat_](https://frippery.org/busybox/BusyBox.html#bzcat)
[_bzip2_](https://frippery.org/busybox/BusyBox.html#bzip2)
[_cal_](https://frippery.org/busybox/BusyBox.html#cal)
[_cat_](https://frippery.org/busybox/BusyBox.html#cat)
[_cdrop_](https://frippery.org/busybox/BusyBox.html#cdrop)
[_chattr_](https://frippery.org/busybox/BusyBox.html#chattr)
[_chmod_](https://frippery.org/busybox/BusyBox.html#chmod)
[_cksum_](https://frippery.org/busybox/BusyBox.html#cksum)
[_clear_](https://frippery.org/busybox/BusyBox.html#clear)
[_cmp_](https://frippery.org/busybox/BusyBox.html#cmp)
[_comm_](https://frippery.org/busybox/BusyBox.html#comm)
[_cp_](https://frippery.org/busybox/BusyBox.html#cp)
[_cpio_](https://frippery.org/busybox/BusyBox.html#cpio)
[_crc32_](https://frippery.org/busybox/BusyBox.html#crc32)
[_cut_](https://frippery.org/busybox/BusyBox.html#cut)
[_date_](https://frippery.org/busybox/BusyBox.html#date)
[_dc_](https://frippery.org/busybox/BusyBox.html#dc)
[_dd_](https://frippery.org/busybox/BusyBox.html#dd)
[_df_](https://frippery.org/busybox/BusyBox.html#df)
[_diff_](https://frippery.org/busybox/BusyBox.html#diff)
[_dirname_](https://frippery.org/busybox/BusyBox.html#dirname)
[_dos2unix_](https://frippery.org/busybox/BusyBox.html#dos2unix)
[_dpkg_](https://frippery.org/busybox/BusyBox.html#dpkg)
[_dpkg-deb_](https://frippery.org/busybox/BusyBox.html#dpkg-deb)
[_drop_](https://frippery.org/busybox/BusyBox.html#drop)
[_du_](https://frippery.org/busybox/BusyBox.html#du)
[_echo_](https://frippery.org/busybox/BusyBox.html#echo)
[_ed_](https://frippery.org/busybox/BusyBox.html#ed)
[_egrep_](https://frippery.org/busybox/BusyBox.html#egrep)
[_env_](https://frippery.org/busybox/BusyBox.html#env)
[_expand_](https://frippery.org/busybox/BusyBox.html#expand)
[_expr_](https://frippery.org/busybox/BusyBox.html#expr)
[_factor_](https://frippery.org/busybox/BusyBox.html#factor)
[_false_](https://frippery.org/busybox/BusyBox.html#false)
[_fgrep_](https://frippery.org/busybox/BusyBox.html#fgrep)
[_find_](https://frippery.org/busybox/BusyBox.html#find)
[_fold_](https://frippery.org/busybox/BusyBox.html#fold)
[_free_](https://frippery.org/busybox/BusyBox.html#free)
[_fsync_](https://frippery.org/busybox/BusyBox.html#fsync)
[_ftpget_](https://frippery.org/busybox/BusyBox.html#ftpget)
[_ftpput_](https://frippery.org/busybox/BusyBox.html#ftpput)
[_getopt_](https://frippery.org/busybox/BusyBox.html#getopt)
[_grep_](https://frippery.org/busybox/BusyBox.html#grep)
[_groups_](https://frippery.org/busybox/BusyBox.html#groups)
[_gunzip_](https://frippery.org/busybox/BusyBox.html#gunzip)
[_gzip_](https://frippery.org/busybox/BusyBox.html#gzip)
[_hd_](https://frippery.org/busybox/BusyBox.html#hd)
[_head_](https://frippery.org/busybox/BusyBox.html#head)
[_hexdump_](https://frippery.org/busybox/BusyBox.html#hexdump)
[_httpd_](https://frippery.org/busybox/BusyBox.html#httpd)
[_iconv_](https://frippery.org/busybox/BusyBox.html#iconv)
[_id_](https://frippery.org/busybox/BusyBox.html#id)
[_inotifyd_](https://frippery.org/busybox/BusyBox.html#inotifyd)
[_install_](https://frippery.org/busybox/BusyBox.html#install)
[_ipcalc_](https://frippery.org/busybox/BusyBox.html#ipcalc)
[_jn_](https://frippery.org/busybox/BusyBox.html#jn)
[_kill_](https://frippery.org/busybox/BusyBox.html#kill)
[_killall_](https://frippery.org/busybox/BusyBox.html#killall)
[_lash_](https://frippery.org/busybox/BusyBox.html#lash)
[_less_](https://frippery.org/busybox/BusyBox.html#less)
[_link_](https://frippery.org/busybox/BusyBox.html#link)
[_ln_](https://frippery.org/busybox/BusyBox.html#ln)
[_logname_](https://frippery.org/busybox/BusyBox.html#logname)
[_ls_](https://frippery.org/busybox/BusyBox.html#ls)
[_lsattr_](https://frippery.org/busybox/BusyBox.html#lsattr)
[_lzcat_](https://frippery.org/busybox/BusyBox.html#lzcat)
[_lzma_](https://frippery.org/busybox/BusyBox.html#lzma)
[_lzop_](https://frippery.org/busybox/BusyBox.html#lzop)
[_lzopcat_](https://frippery.org/busybox/BusyBox.html#lzopcat)
[_make_](https://frippery.org/busybox/BusyBox.html#make)
[_man_](https://frippery.org/busybox/BusyBox.html#man)
[_md5sum_](https://frippery.org/busybox/BusyBox.html#md5sum)
[_mkdir_](https://frippery.org/busybox/BusyBox.html#mkdir)
[_mktemp_](https://frippery.org/busybox/BusyBox.html#mktemp)
[_mv_](https://frippery.org/busybox/BusyBox.html#mv)
[_nc_](https://frippery.org/busybox/BusyBox.html#nc)
[_nl_](https://frippery.org/busybox/BusyBox.html#nl)
[_nproc_](https://frippery.org/busybox/BusyBox.html#nproc)
[_od_](https://frippery.org/busybox/BusyBox.html#od)
[_paste_](https://frippery.org/busybox/BusyBox.html#paste)
[_patch_](https://frippery.org/busybox/BusyBox.html#patch)
[_pdpmake_](https://frippery.org/busybox/BusyBox.html#pdpmake)
[_pdrop_](https://frippery.org/busybox/BusyBox.html#pdrop)
[_pgrep_](https://frippery.org/busybox/BusyBox.html#pgrep)
[_pidof_](https://frippery.org/busybox/BusyBox.html#pidof)
[_pipe_progress_](https://frippery.org/busybox/BusyBox.html#pipe_progress)
[_pkill_](https://frippery.org/busybox/BusyBox.html#pkill)
[_printenv_](https://frippery.org/busybox/BusyBox.html#printenv)
[_printf_](https://frippery.org/busybox/BusyBox.html#printf)
[_ps_](https://frippery.org/busybox/BusyBox.html#ps)
[_pwd_](https://frippery.org/busybox/BusyBox.html#pwd)
[_readlink_](https://frippery.org/busybox/BusyBox.html#readlink)
[_realpath_](https://frippery.org/busybox/BusyBox.html#realpath)
[_reset_](https://frippery.org/busybox/BusyBox.html#reset)
[_rev_](https://frippery.org/busybox/BusyBox.html#rev)
[_rm_](https://frippery.org/busybox/BusyBox.html#rm)
[_rmdir_](https://frippery.org/busybox/BusyBox.html#rmdir)
[_rpm_](https://frippery.org/busybox/BusyBox.html#rpm)
[_rpm2cpio_](https://frippery.org/busybox/BusyBox.html#rpm2cpio)
[_sed_](https://frippery.org/busybox/BusyBox.html#sed)
[_seq_](https://frippery.org/busybox/BusyBox.html#seq)
[_sh_](https://frippery.org/busybox/BusyBox.html#sh)
[_sha1sum_](https://frippery.org/busybox/BusyBox.html#sha1sum)
[_sha256sum_](https://frippery.org/busybox/BusyBox.html#sha256sum)
[_sha3sum_](https://frippery.org/busybox/BusyBox.html#sha3sum)
[_sha512sum_](https://frippery.org/busybox/BusyBox.html#sha512sum)
[_shred_](https://frippery.org/busybox/BusyBox.html#shred)
[_shuf_](https://frippery.org/busybox/BusyBox.html#shuf)
[_sleep_](https://frippery.org/busybox/BusyBox.html#sleep)
[_sort_](https://frippery.org/busybox/BusyBox.html#sort)
[_split_](https://frippery.org/busybox/BusyBox.html#split)
[_ssl_client_](https://frippery.org/busybox/BusyBox.html#ssl_client)
[_stat_](https://frippery.org/busybox/BusyBox.html#stat)
[_strings_](https://frippery.org/busybox/BusyBox.html#strings)
[_su_](https://frippery.org/busybox/BusyBox.html#su)
[_sum_](https://frippery.org/busybox/BusyBox.html#sum)
[_sync_](https://frippery.org/busybox/BusyBox.html#sync)
[_tac_](https://frippery.org/busybox/BusyBox.html#tac)
[_tail_](https://frippery.org/busybox/BusyBox.html#tail)
[_tar_](https://frippery.org/busybox/BusyBox.html#tar)
[_tee_](https://frippery.org/busybox/BusyBox.html#tee)
[_test_](https://www.busybox.net/downloads/BusyBox.html#test)
[_time_](https://frippery.org/busybox/BusyBox.html#time)
[_timeout_](https://frippery.org/busybox/BusyBox.html#timeout)
[_touch_](https://frippery.org/busybox/BusyBox.html#touch)
[_tr_](https://frippery.org/busybox/BusyBox.html#tr)
[_true_](https://frippery.org/busybox/BusyBox.html#true)
[_truncate_](https://frippery.org/busybox/BusyBox.html#truncate)
[_ts_](https://frippery.org/busybox/BusyBox.html#ts)
[_tsort_](https://frippery.org/busybox/BusyBox.html#tsort)
[_ttysize_](https://frippery.org/busybox/BusyBox.html#ttysize)
[_uname_](https://frippery.org/busybox/BusyBox.html#uname)
[_uncompress_](https://frippery.org/busybox/BusyBox.html#uncompress)
[_unexpand_](https://frippery.org/busybox/BusyBox.html#unexpand)
[_uniq_](https://frippery.org/busybox/BusyBox.html#uniq)
[_unix2dos_](https://frippery.org/busybox/BusyBox.html#unix2dos)
[_unlink_](https://frippery.org/busybox/BusyBox.html#unlink)
[_unlzma_](https://frippery.org/busybox/BusyBox.html#unlzma)
[_unlzop_](https://frippery.org/busybox/BusyBox.html#unlzop)
[_unxz_](https://frippery.org/busybox/BusyBox.html#unxz)
[_unzip_](https://frippery.org/busybox/BusyBox.html#unzip)
[_uptime_](https://frippery.org/busybox/BusyBox.html#uptime)
[_usleep_](https://frippery.org/busybox/BusyBox.html#usleep)
[_uudecode_](https://frippery.org/busybox/BusyBox.html#uudecode)
[_uuencode_](https://frippery.org/busybox/BusyBox.html#uuencode)
[_vi_](https://frippery.org/busybox/BusyBox.html#vi)*(*[_tutorial_](https://k.japko.eu/busybox-vi-tutorial.html)*)*
[_watch_](https://frippery.org/busybox/BusyBox.html#watch)
[_wc_](https://frippery.org/busybox/BusyBox.html#wc)
[_wget_](https://frippery.org/busybox/BusyBox.html#wget)
[_which_](https://frippery.org/busybox/BusyBox.html#which)
[_whoami_](https://frippery.org/busybox/BusyBox.html#whoami)
[_whois_](https://frippery.org/busybox/BusyBox.html#whois)
[_xargs_](https://frippery.org/busybox/BusyBox.html#xargs)
[_xxd_](https://frippery.org/busybox/BusyBox.html#xxd)
[_xz_](https://frippery.org/busybox/BusyBox.html#xz)
[_xzcat_](https://frippery.org/busybox/BusyBox.html#xzcat)
[_yes_](https://frippery.org/busybox/BusyBox.html#yes)
[_zcat_](https://frippery.org/busybox/BusyBox.html#zcat)


_Note:_ Подробное описание по командам на русском языке можно найти на сайте <https://www.opennet.ru/man_1.shtml>.

#### _Некоторые утилиты:_ {.unnumbered .unlisted}


#### du и df

`du` --- Disk Usage --- показывает объём, занимаемый файлами и/или папками; опция `-s` --- суммарный размер, а не каждого элемента.\
`df` --- Disk Full --- показывает объём дисков, полный, свободный, занятый.

Посмотреть занимаемое место файлами и/или папками:
```cmd
du -sh .
du -sh some-folder
du -sh * | sort -h
```

Посмотреть общее и занятое место на дисках:
```cmd
df -h
```

#### head и tail

`head -n3 *.txt` --- вывести первые три строки;\
`head -n-3 *.txt` --- вывести все строки кроме последних трёх;\
`tail -n3 *.txt` --- вывести три последних строки;\
`tail -n+3 *.txt` --- вывести все строки кроме первых трёх;\
\
`tail -n+1 *.txt` --- вывести содержимое всех файлов, предварив названием файла.

#### paste

Объединяет несколько текстовых файлов таким образом, что в объединённом файле каждая строка состоит из строки первого файла, затем идёт разделитель (*--delimiter*), затем строка второго, и т.д. Данная утилита удобна для объединения нескольких файлов мониторинга (лог-файлов) в один файл.

`paste -d' ' data1.out data2.out > data.out`


#### join

Объединяет два текстовых файла по одинаковым значениям в первом поле каждой строки --- объединяет данные по первому столбцу. Данные должны быть отсортированы по объединяемому полю. Данная утилита удобна для объединения нескольких файлов мониторинга (лог-файлов) в один файл.

`join data1.out data2.out > data.out`

#### wget

Скачивает с инета страницу или файл: `wget URL`

Скачать сайт: `-r` --- recursive, `-np` --- no-parent, `-p` --- также скачать всё что требуется для отображения страницы, `-c` --- продолжить (continue) закачку с места разрыва, если он случится, `--restrict-file-names=nocontrol` --- после загрузки не [экранировать](https://www.gnu.org/software/wget/manual/wget.html#index-file-names_002c-restrict) русские буквы в именах файлов. URL не обязательно должен быть корневой страницей.

```cmd
wget -r -np -p -c --restrict-file-names=nocontrol URL
```

#### xargs

Применить команду к каждой строке в списке:
```cmd
fd --hidden "\.vhdx$" %HOME% | xargs -I@ cp -v @ E:\backup\wsl\
```


#### watch

Опция `-d` подсвечивает изменения.

`watch -d df -h` --- отслеживать заполненность дисков; по умолчанию, периодичность 2 секунды.

*\<TBD\>*

`watch -d 'cat /proc/vmstat | grep numa'` --- отслеживать результат периодического выполнения команды.

### Совпадающие системные имена

С помощью алиасов можно настроить нормальные имена для Linux утилит, имена которых совпадают с именами системных Windows утилит.

Например, настроить имя для утилит `sort`, `time`. Для _Clink_ добавить строчки в *"%LOCALAPPDATA%\\clink\\clink_start.cmd"*:
```cmd
doskey sort=%UserProfile%\scoop\shims\sort.exe $*
doskey time=%UserProfile%\scoop\shims\time.exe $*
```

_Note:_ Для _PowerShell_ смотри соответствующий пункт главы [Настройки Windows Terminal](#настройка-windows-terminal).



# Работа с документами

## Офисные пакеты

Существует, как минимум, два офисных пакета с открытым исходным кодом: [LibreOffice](https://www.libreoffice.org/) и [OnlyOffice](https://www.onlyoffice.com/ru/desktop.aspx), которые позиционируются как вполне разумная замена MSOffice для вариантов персонального использования. У MSOffice есть заметные преимущества в совместной, распределённой работе над документами в организациях, с поддержкой сервиса SharePoint/OneDrive, и т.п., но и здесь появились альтернативы. У всех пакетов есть ленточный/ribbon интерфейс схожий с MSOffice. Все поддерживают стили MSOffice, отображение и набор формул.

_Note:_ у всех офисных пакетов есть некоторое несовпадение в отображении открытых документов с MSOffice, которое связано с тем, что пользователи оформляют документы и презентации не на основе стилей, а вручную подгоняя вид пробелами и отступами. Если же использовать правильный, рекомендуемый Microsoft, поход к оформлению документов, то различия в отображении документов будут минимальны, а скорее всего, вообще неразличимы.

Общие рекомендации при использовании офисных пакетов:

* Использовать исключительно стили для оформления. Пора забыть про пробелы и табы для выравнивания!
* Шаблоны --- это основа любого документа!
* При редактировании чужого документа обязательно включать режим правок/рецензирования!
* Якори --- это плохо!
* _.doc_ давно пора закопать!
* Пора обновить свой офисный пакет, ему уже почти 20 лет, там всё стало намного удобнее.

### LibreOffice

[**LibreOffice**](https://www.libreoffice.org/)\
Консервативный офисный пакет для персонального использования. Превосходно справляется с конвертацией документов из/в форматов MSOffice; единственное бесплатное приложение, которое умеет правильно читать документы старого формата _.doc_.

```cmd
scoop bucket add extras
scoop install extras/libreoffice
scoop shim add soffice %UserProfile%\scoop\apps\libreoffice\current\LibreOffice\program\soffice.exe
scoop shim add loffice %UserProfile%\scoop\apps\libreoffice\current\LibreOffice\program\soffice.exe
```

_Note:_ В последних версиях есть _ленточный (ribbon)_ стиль оформления интерфейса, похожий на MSOffice; включение через _View > User Interface: UI Variants > Tabbed_; выключение через это же меню, которое будет расположено в правом верхнем углу в виде трёх полосочек.

_Note:_ для мониторов с высоким разрешением (High DPI) потребуется переключиться на _SVG_ набор иконок в меню (`<Alt-F12>`) _Tools > Options > LibreOffice > View_. _Ленточный (ribbon)_ интерфейс не совместим с мониторами с высоким разрешением.

Применение для конвертации _.doc_ в _.docx_ (с обновлением в поддерживаемый формат MSEquation), в текущей папке:
```cmd
soffice -headless -convert-to docx *.doc
```

То же, рекурсивно по папкам:
```cmd
fd -e doc --exec soffice -convert-to docx {}
```

Вывести содержимое _.doc_/_.docx_ на экран:
```cmd
soffice -cat somedoc.doc
```

### OnlyOffice

[**OnlyOffice**](https://www.onlyoffice.com/ru/desktop.aspx) --- офисный пакет от Российских разработчиков, участвует в программе импортозамещения. Opensource, кроссплатформенный, имеет версию для Android и iOS. В качестве формата хранения документов использует форматы файлов MSOffice (какого-то своего особенного формата не имеет). Умеет редактировать _pdf_. Установка:
```cmd
winget install --id=ONLYOFFICE.DesktopEditors -e
```

Помимо десктоп версии, у OnlyOffice есть открытая [версия офиса для облачного, совместного использования](https://www.onlyoffice.com/ru/office-for-nextcloud.aspx) на платформе частного облака [NextCloud](https://apps.nextcloud.com/apps/onlyoffice). Но, данные возможности не имеют смысла при персональном, не коллективном использовании, буквально избыточны; поэтому, здесь только [ссылка на guide](https://nextcloud.com/blog/your-guide-to-the-nextcloud-all-in-one-on-windows-10-11/) по установке для желающих попробовать.

Также у OnlyOffice есть [OnlyOffice-Server](https://github.com/ONLYOFFICE/DocumentServer), предназначенный для организации облачного сервиса, аналога Office365 и SharePoint/OneDrive, с поддержкой распределённой, совместной работы.

> _Отступление про редактирование pdf._\
  Внутренний формат pdf не содержит информации о последовательности символов и слов, а содержит информацию, в каком месте страницы нарисовать тот или символ или слово (и, как следствие, пробелы тоже не хранит). Даже в отдельном параграфе слова не обязательно будут в естественном порядке. С математическими формулами или таблицами ситуация совсем катастрофическая. Поэтому, все программы для редактирования pdf "додумывают" информацию о том, в какой последовательности идут символы и слова. Поэтому, самый лучший способ редактирования pdf, это сконвертировать pdf в Markdown методом OCR или ИИ, и полученный Markdown сконвертировать в docx.

### Collabora

[**Collabora Online**](https://www.collaboraonline.com/collabora-office/)\
Ещё один бесплатный открытый офисный пакет с возможностью совместного, распределённого редактирования документов; эти возможности хорошо интегрированы в платформу частного облака [NextCloud](https://nextcloud.com/office/). Этот офисный пакет работает исключительно "онлайн", т.е. его нельзя "установить" на компьютер. Опять же, для персонального использования это избыточно; и здесь упоминается только для полноты обзора.

### MSOffice tips

#### Нумерация рисунков в Word

Сначала необходимо вставить рисунок в документ, выбрав соответствующий пункт меню «Вставка» и выбрав рисунок из файловой системы или из другого источника. Затем, после вставки рисунка, необходимо выбрать его и перейти во вкладку «Ссылки» в верхнем меню Word.

Во вкладке «Ссылки» находится группа команд «Подписи», которая содержит кнопку «Подписи для рисунков». При нажатии на эту кнопку открывается диалоговое окно, в котором можно выбрать опции для автоматической нумерации рисунков. В окне можно указать формат нумерации, префикс и суффикс для нумерации, а также выбрать стиль подписей для рисунков.

[link](https://uchet-jkh.ru/i/kak-sdelat-avtonumeraciyu-risunkov-v-word/).

#### Сделать прозрачным фон картинок в PowerPoint

Раньше (2003) этот пункт меню был в быстром доступе на панели работы с рисунками. Сейчас он спрятан в
*\<TBD\>*

## Текстовые документы

На данный момент [Markdown](https://ru.wikipedia.org/wiki/Markdown) это основной формат разметки для текстовых документов. Помимо этого существует ещё пара десятков форматов с аналогичным функционалом (в том числе LaTeX), но после того, как [github](https://docs.github.com/en/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax) взял Markdown в качестве своего основного языка разметки, все остальные постепенно вышли из использования.

Ещё существует LaTeX, но это излишне переусложнённо и не читабельно для целей написания простых статей, веб-страниц, или документации к программам. Здесь LaTeX упоминается только из-за его языка разметки математических выражений, который повсеместно распространился, в отрыве от самого LaTeX'а.

Основополагающей идеей Markdown является сохранение, и, даже, повышение читабельности текста, чтобы можно было читать и писать документы в любом простом редакторе. В [Markdown](https://www.markdownguide.org/basic-syntax/) есть аннотации для выделения и оформления таких элементов, как: заголовки, параграфы, списки, таблицы, акценты текста, встраивание рисунков, аннотация кода, встраивание математических формул, сноски, ссылки на главы и ссылки на внешние ресурсы. Существуют расширения Markdown для: библиографий и цитирования, рисования диаграмм, выполнения кода скриптов. С одной стороны, это простой текст который можно просматривать хоть выводом `cat` на экран, а с другой стороны, для Markdown есть множество приложений для полноценного графического отображения содержимого в виде, привычном по офисным редакторам.

В силу того, что Markdown это всё же просто текст, то в нём не содержится каких-либо стилей или графического оформления. Таким занимаются программы для отображения, рендеринга и конвертации. Именно в этих программах будет выбираться размер шрифта, межстрочный интервал и т.п. при конвертации в pdf или docx. Обычно, это применение либо встроенных в программы шаблонов стиля, либо использование шаблонов стиля предоставляемых пользователем.

### Markdown

Редактирование **Markdown** и синхронное отображение поддерживается в _VSCode_ "из коробки", в том числе, есть отображение картинок, таблиц, формул, сносок, и проч. <https://code.visualstudio.com/docs/languages/markdown>. Встроенный в VSCode Markdown Preview можно донастраивать расширениями. Открыть превью в _VSCode_: `Ctrl+Shift+V`.

Для просмотра без редактирования можно использовать любой браузер с одним из плагинов для просмотра Markdown, например [Markdown Viewer](https://github.com/simov/markdown-viewer#markdown-viewer--browser-extension). Это расширение предоставляет возможность использовать все возможности Markdown: формулы, рисунки, таблицы, сноски, и т.д.

В Google docs Markdown --- это один из [форматов для экспорта](https://support.google.com/docs/answer/12014036), причём, при экспорте, рисунки становятся встроенными (embedded) прямо в файл _.md_.

Для конвертации _в_ и _из_ формата Markdown во всевозможные другие применяется конвертер _pandoc_, о нём будет [дальше](#универсальный-конвертер-pandoc).

### Quarto

[**Quarto**](https://quarto.org/) --- система вёрстки на основе Markdown, с одновременным отображением отрендеренного содержимого:

* умеет [показывать формулы, картинки, код, таблицы](https://quarto.org/docs/authoring/markdown-basics.html);

* может выполнять код на [_Julia_](https://quarto.org/docs/computations/julia.html), [_Python_](https://quarto.org/docs/computations/python.html), [_R_](https://quarto.org/docs/computations/r.html), [_Observable JS_](https://quarto.org/docs/computations/ojs.html), и [показывать результат выполнения в тексте](https://quarto.org/docs/computations/inline-code.html);

* умеет отображать [диаграммы](https://quarto.org/docs/authoring/diagrams.html) в форматах [Mermaid](https://mermaid.js.org/) и [Graphviz](https://graphviz.org/) (_dot_);

* формат файлов Quarto (_.qmd_) --- это Markdown с некоторыми расширениями, т.е. простой текстовый файл, который можно редактировать в любом текстовом редакторе;

* поддерживается в [VSCode расширении](http://marketplace.visualstudio.com/items?itemName=quarto.quarto), с возможностью синхронного отображения отрендеренного содержимого;

* _.qmd_ файлы конвертируются (рендерятся) в форматы _pdf_, _docx_, _pptx_, _html_ с учётом заданных стилей:

  + Quarto имеет предустановленные [стили](https://quarto.org/docs/output-formats/pdf-basics.html#document-class), для оформления [статей](https://quarto.org/docs/output-formats/ms-word.html), [презентаций](https://quarto.org/docs/presentations/powerpoint.html), [сайтов](https://quarto.org/docs/websites/), и др. В случае отсутствия явного указания стиля будет использован стиль по умолчанию _article_.

  + вместо предустановленных стилей, можно задавать пользовательские стили; их можно указать либо в виде файла шаблона стилей _dotx_ или _potx_, либо указать на файл готового документа _docx_ или _pptx_, с которого будет скопирован стиль оформления. Для оформления _pdf_ можно непосредственно внедрять код _LaTeX_ для явного указания стилей и/или пакетов;

* умеет [загружать](https://quarto.org/docs/tools/jupyter-lab.html) _.ipynb_ и рендерить в различные форматы;

* [JupyterLab](https://quarto.org/docs/tools/jupyter-lab-extension.html) умеет показывать Quarto с полным форматированием;

* [может отрендерить](https://quarto.org/docs/computations/render-scripts.html) обычные файлы с кодом *.py*, *.jl*, *.R* в _pdf_, _html_ и т.п., где в файлах в комментариях специального формата ([*percent format*](https://jupytext.readthedocs.io/en/latest/formats-scripts.html#the-percent-format)) помещены _Markdown_ блоки. Данный подход позволяет вести разработку программ привычным способом, а по завершении разработки сгенерировать документ отчёта прямо с файла программы;

* "под капотом" использует [pandoc](https://pandoc.org/).

Установка:
```cmd
winget install --id=Posit.Quarto -e
python3 -m pip install nbclient
quarto install tinytex
quarto install chromium
```

Можно [использовать в VSCode](https://quarto.org/docs/tools/vscode.html) с соответствующим [плагином](http://marketplace.visualstudio.com/items?itemName=quarto.quarto). А можно просто написать _.qmd_ файл в любом редакторе, и сконвертировать в [выбранный формат](https://quarto.org/docs/output-formats/all-formats.html): `quarto render win11-for-engineers-manual.qmd` (как данное руководство).


#### Выполняемые блоки кода {.unnumbered .unlisted}

Помимо отображения блоков кода и математических формул в _LaTeX_ нотации в Markdown/Quarto документы можно добавлять выполняемые блоки кода, результат выполнения которых будет подставлен на страницу, для примера, в главе про [Matplotlib](#matplotlib) показан блок кода на питон и результат его выполнения тут же добавлен в документ. Выполняемые блоки кода аннотируются фигурными скобками вокруг названия типа блока кода, например, `{python}`. Как и в других [_Интерактивных блокнотах_](#блокноты-на-python), в _Quarto_ выполняемые блоки кода имеют единое пространство имён, т.е. объявив переменную в одном блоке, она будет доступна в последующих блоках, причём даже в блоках разного типа:

```{julia}
#| echo: fenced
n = 3
```

```{python}
for i in range(1, $n + 1):
    print("i =", i)
```

Также, Quarto выполняет и выводит [диаграммы](https://quarto.org/docs/authoring/diagrams.html), с использованием аннотированных блоков кода в форматах [Mermaid](https://mermaid.js.org/) ([примеры](https://github.com/mermaid-js/mermaid#examples)) и [Graphviz(dot)](https://graphviz.org/) ([примеры](https://renenyffenegger.ch/notes/tools/Graphviz/examples/index)). _Note:_ помимо этих двух типов диаграмм в Quarto есть поддержка [других типов диаграмм](https://github.com/pandoc-ext/diagram#diagram-types) (*TikZ* и др.) через [плагины pandoc](https://github.com/pandoc-ext).

Пример диаграммы Mermaid со [страницы](https://quarto.org/docs/authoring/diagrams.html) документации Quarto. Этот блок кода Mermaid выполняется по месту и отрисовывается вместо кода:

```{mermaid}
%%| echo: false
flowchart LR
  A[Hard edge] --> B(Round edge)
  B --> C{Decision}
  C --> D[Result one]
  C --> E[Result two]
```

На месте диаграммы в этом документе, на самом деле, стоит код Mermaid код с аннотацией выполнения (`{}`):

```{{mermaid}}
flowchart LR
  A[Hard edge] --> B(Round edge)
  B --> C{Decision}
  C --> D[Result one]
  C --> E[Result two]
```

Аналогично работает отрисовка диаграмм Graphviz (_dot_), здесь показан пример сразу вместе с блоком кода:

```{dot}
//| echo: fenced
//| fig-width: 6
//| fig-height: 1.5
digraph G {
  rankdir = LR;

  A [label="Hard edge" shape=box];
  B [label="Round edge" shape=ellipse];
  C [label="Decision" shape=diamond];
  D [label="Result one" shape=box];
  E [label="Result two" shape=box];

  A -> B;
  B -> C;
  C -> D;
  C -> E;
}
```

Выполняемые блоки кода для языков _Python_, _Julia_ и *R*, по умолчанию, отображаются вместе с результатами их выполнения; выполняемые блоки кода диаграмм по умолчанию не отображаются в результирующем документе. Это можно изменить опцией выполнения `#| echo:`, что было проделано выше на примере диаграммы Graphviz добавлением опции `//| echo: fenced`; подробности опций отображения блоков кода и результатов выполнения описаны в [документации](https://quarto.org/docs/computations/execution-options.html#output-options).


В документе Quarto могут выполняться достаточно большие блоки кода, их результат выполнения будет отрисован в документе, и, вполне возможно, создавать статьи, или, скажем, курсовые работы вместе отчётом, в одном _qmd_ файле. При наличии большого числа блоков кода, или длительных вычислений в них, для контроля времени затрачиваемого на выполнения блоков кода во время рендеринга (`quarto render`) существуют опции [запрета](https://quarto.org/docs/computations/python.html#freezing-execution) на выполнение или выполнения только при изменении кода, [кеширования](https://quarto.org/docs/computations/python.html#caching) результатов выполнения и другие.

##### Некоторые особенности блоков Julia

В современных версиях _Quarto_, для выполняемых блоков кода языка _Julia_ есть возможность их выполнения [непосредственно в julia](https://quarto.org/docs/computations/julia.html#using-the-julia-engine) (по умолчанию используется _Jupyter_). Для этого в заголовке необходимо прописать опцию `engine: julia`; этого достаточно для Quarto документов с блоками кода _Julia_. Если же в qmd-документе, при этом, присутствуют одновременно ещё _Python_, или _R_ блоки, то дополнительно потребуется [выполнить следующую команду](https://quarto.org/docs/computations/julia.html#r-and-python-support) в текущей директории:
```sh
julia --project=. -e 'import Pkg; Pkg.add("PythonCall"); Pkg.add("CondaPkg"); Pkg.add("RCall");'
julia --project=. -e 'import Pkg; Pkg.build("PythonCall"); Pkg.build("CondaPkg"); Pkg.build("RCall");'
julia --project=. -e 'using PythonCall'
```

что эквивалентно выполнению следующих команд в терминале julia:

```julia
julia> import Pkg
julia> Pkg.activate(".")
julia> Pkg.add("PythonCall")
julia> Pkg.add("CondaPkg")
julia> Pkg.add("RCall")
julia> Pkg.build("PythonCall")
julia> Pkg.build("CondaPkg")
julia> Pkg.build("RCall")
julia> using PythonCall
```

Эти операции требуются для загрузки пакета _PythonCall_, а также его предзагрузки и инициализации, в процессе которой будет также установлен пакет NumPy.

Для [добавления пакетов _Python_](https://juliapy.github.io/PythonCall.jl/stable/pythoncall/#python-deps) следует выполнить команды:

```sh
julia --project=. -e 'import CondaPkg; CondaPkg.add("numpy");  CondaPkg.add("matplotlib");'
```

или

```julia
julia> using CondaPkg
julia> # press ] to enter the Pkg REPL
pkg> conda add numpy
pkg> conda add matplotlib
```

Также потребуется установить используемые в выполняемых блоках кода Julia пакеты, например, `Pkg.add("Plots")`.

_Note:_ При использовании `engine: julia` (и, соответственно, пакета _QuartoNotebookRunner_) имеет место [баг](https://github.com/quarto-dev/quarto-cli/issues/8373), в связи с чем следует в заголовке в секции _format_ объявлять _html_ перед _pdf_:
```yaml
format:
  html:
  pdf:
```

_Note:_ В случае возникновения ошибки про *Qt6Base_jll* при выполнении команды `quarto render` следует выполнить эту команду повторно.

> _Note:_ Хотелось бы отметить, что смешение языков выполняемых блоков в одном qmd-документе --- это плохая идея.

### _LaTeX_

Существует сайт [overleaf.com](https://www.overleaf.com/) --- это онлайн-редактор _LaTeX_ с поддержкой автоматического рендеринга (отображения) результата, контроля версий, совместного редактирования. Если требуется написать статью на _LaTeX_, а не знаешь как, то этот сайт это правильный выбор. А если знаешь как, то какие-либо советы излишни.

### Универсальный конвертер Pandoc

[**pandoc**](https://pandoc.org/) --- инструмент командной строки (CLI) для конвертации документов в различных форматах в документы других различных форматов: pdf, docx, pptx, html, Markdown могут быть сконвертированы друг в друга почти без ограничений, в том числе и с сохранением математических формул. Поддерживает перенос библиографий, цитирования, стилей оформления, таблиц в другие форматы файлов. Усть ограничение: pdf нельзя сконвертировать в другие форматы. Установка:
```cmd
scoop install pandoc
```

Примеры [использования](https://pandoc.org/demos.html):
```cmd
pandoc --from=html --to=markdown --wrap=none some-saved-site-page.html
```
```cmd
pandoc --to=markdown --wrap=none mine-article-with-math-formulas.docx
```
```cmd
pandoc -s math.tex -o example30.docx
```

Опцию `--from` использовать необязательно, `pandoc` в большинстве случаев автоматически поймёт исходный формат по расширению или содержимому. Выходной формат надо обозначать в случаях неоднозначного соответствия расширения файла формату, как в случае с _.md_, которому соответствует несколько диалектов Markdown. См. руководство <https://pandoc.org/MANUAL.html>.

## Программы для ведения заметок

Приложения для ведения заметок разделяются по способу хранения базы заметок: один локальный файл с базой, множество локальных _.md_ файлов и картинок, облачное хранение. Выбор программы во многом определяется выбором способа хранения.

Среди множества существующих программ для ведения заметок следует рассматривать только opensource программы, которые используют формат Markdown и поддерживают формулы в LaTeX нотации: [https://alternativeto.net/category/productivity/note-taking/](https://alternativeto.net/category/productivity/note-taking/?feature=latex-support&license=opensource). Программ много, можно выбрать на любой вкус.

### Logseq


Пример приложения с хранением каждой записи в отдельном файле --- [**Logseq**](https://logseq.com/). Считается [свободной](https://github.com/logseq/logseq) альтернативой _Obsidian._ [Гайд по LogSeq](https://vas3k.club/post/25661/).

```cmd
winget install --id=Logseq.Logseq  -e
```

### dendron

Ещё одно приложение с хранением каждой записи в отдельном файле --- плагин [**dendron**](https://github.com/dendronhq/dendron) для [VSCode](https://marketplace.visualstudio.com/items?itemName=dendron.dendron). Это приложение в качестве основной особенности указывает удобный поиск и навигацию по базе в десятки тысяч заметок. [Инструкция](https://learn.microsoft.com/ru-ru/shows/vs-code-livestreams/note-taking-inside-of-vs-code).

### TiddlyWiki

В качестве программы для ведения заметок с одним локальным файлом можно рассмотреть **TiddlyWiki** --- <https://tiddlywiki.com>. Это браузерное JavaScript приложение в виде одного _.html_ файла, т.е., чтобы посмотреть или отредактировать заметки, не потребуется установка каких-либо программ, а всего лишь открыть этот файл в браузере. Поддерживает язык разметки [Markdown](https://ru.wikipedia.org/wiki/Markdown) и формулы [LaTeX](https://en.wikibooks.org/wiki/LaTeX/Mathematics). Минус этого приложения автоматически вытекает из его плюса --- так как база заметок это один файл, то при добавлении картинок этот файл быстро разрастается до десятков, если не сотен мегабайт, и становится тормозным. А если вставлять картинки в виде ссылок на файлы, то теряется концепция хранилища в виде одного файла. Можно использовать векторные картинки, например в формате SVG, но их сложно делать, а [tikz](https://tikz.net/) не поддерживается. Так же из минусов --- это отсутствие Autosave "из коробки".

Для удобства использования потребуется настроить Autosave для TiddlyWiki: в _Firefox_ установить плагин [_Timimi_](https://addons.mozilla.org/en-US/firefox/addon/timimi/), также установить приложение [_timimi-2-1-1-Windows-Firefox.exe_](https://github.com/ibnishak/Timimi/releases). Autosave работает только в _Firefox_, в _Chromium_ почему-то не работает.

Скачать <https://tiddlywiki.com/#GettingStarted> --- пустой файл заметок. Открыть в _Firefox_. Установить плагины:\
_CodeMirror_\
_CodeMirror Close Brackets_\
_CodeMirror Mode Markdown_\
_CodeMirror Search and Replace_\
_Highlight_\
_KaTeX_\
_Markdown_

_Note:_ Есть поддержка режима редактирования Vim в плагине _CodeMirror Keymap Vim_. Но для _очень_ продвинутых пользователей этот плагин не актуален, так как они уже настроили себе расширение <https://github.com/glacambre/firenvim>.

### AI-based

*Данный пункт написан при поддержке LLM.*

Появляются приложения со встроенными ИИ-помощниками (ассистентами). Разумно предположить, что в недалёком будущем это станет мейнстримом --- облегчение человеческой деятельности в областях монотонной или однообразной работы.

Одним из таких приложений с интеграцией ИИ-ассистента является [Reor](https://www.reorproject.org/), это [опенсорс](https://github.com/reorproject/reor) приложение для ведения заметок. В Reor встроена утилита Ollama, которая позволяет использовать локальную языковую модель (LLM). Также поддерживается подключение внешних LLM через OpenAI-совместимый протокол. _Note:_ Для работы с локальными LLM для приложения требуется мощный компьютер, точнее, требуется наличие видеокарты.

Заметки в Reor хранятся в виде отдельных Markdown-файлов (*.md*), организованных в папках. Пользователь может создавать подпапки для структурирования информации. При установке можно указать папку с уже существующими Markdown-заметками, и Reor продолжит работу с ними, не нарушая текущую организацию файлов.

В процессе работы Reor выступает как RAG AI-ассистент (Retrieval-Augmented Generation). Это означает, что встроенная языковая модель (LLM) анализирует содержимое заметок и на основе этого предоставляет дополнительные функции: отвечает на вопросы, учитывает контекст заметок, автоматически устанавливает семантические связи между ними и предлагает подсказки при написании текста. Подробнее [на официальной сайте](https://www.reorproject.org/).

[Установка](https://winstall.app/apps/ReorProject.Reor) Reor:
```bash
winget install --id=ReorProject.Reor -e
```

_Note:_ В целом, на данном этапе развития, не стоит ожидать от таких приложений чего-то выдающегося. Да и шумит компьютер сильно при работе с локальными LLM.

Подробнее про используемые термины и технологии в [Приложение: AI/LLM](#приложение-aillm).


## Обработка картинок и создание видео

### ImageMagick

[**ImageMagick**](https://imagemagick.org/index.php) --- пакетная обработка файлов изображений из командной строки.

```cmd
scoop install imagemagick
```

_Note:_ [GraphicsMagick](https://scoop.sh/#/apps?q=graphicsmagick) --- тоже самое, что и ImageMagick, но работает быстрее --- лучше распараллеливается, но, может _~~глючить~~ выполнять обработку с ошибками_. Запускается в точности как ImageMagick, только с префиксом _gm_, а не _magick_, например: `gm mogrify ...`. ~~Использовать стоит только в случае обработки очень большого количества файлов (сотни и больше), и убедившись, что GraphicsMagick выполняет всё идентично с ImageMagick~~ Использовать не стоит, так как для параллелизации есть другие инструменты, например, [_GNU parallel_](#parallel).

_ImageMagick_ применяется как `magick operation ...`, где _operation_:

* `convert` преобразует изображение и записывает результат в другой указанный файл.

* `mogrify` модифицирует исходный файл.

* `montage` собирает (монтирует) несколько изображений в один файл. По умолчанию уменьшает размер до 120x120. `montage -mode concatenate -tile 1x -geometry 1920x1080 *.jpg out.jpg` --- соединить все изображения в одну вертикальную ленту, отмасштабировав в один размер 1920x1080 с сохранением пропорций.

_Note:_ Порядок опций имеет значение --- несколько действий будут выполняться друг за другом, а опции, вроде _-gravity_, или указания цвета, имеют влияние только на следующие за ними команды.

_Note:_ префикс `magick` можно опускать и применять непосредственно соответствующие утилиты; кроме `convert`, имя которой совпадает с одноимённой утилитой Windows.


+-------------------------------------------------+-------------------------------------------------------------------------------------------------+
| Размер                                          | Общее описание[^фактическое]                                                                    |
+:================================================+:================================================================================================+
| *scale***%**                                    | Высота и ширина масштабируются на указанный процент.                                            |
+-------------------------------------------------+-------------------------------------------------------------------------------------------------+
| *scale-x***x***scale-y***%**                    | Высота и ширина масштабируются отдельно на указанные проценты.                                  |
+-------------------------------------------------+-------------------------------------------------------------------------------------------------+
| *width***x**                                    | Ширина задана, высота автоматически подбирается для сохранения соотношения сторон.              |
+-------------------------------------------------+-------------------------------------------------------------------------------------------------+
| **x***height*                                   | Высота задана, ширина автоматически подбирается для сохранения соотношения сторон.              |
+-------------------------------------------------+-------------------------------------------------------------------------------------------------+
| *width***x***height*                            | Заданы максимальные значения высоты и ширины, соотношение сторон сохраняется.                   |
+-------------------------------------------------+-------------------------------------------------------------------------------------------------+
| *width***x***height***^**                       | Заданы минимальные значения ширины и высоты, соотношение сторон сохраняется.                    |
+-------------------------------------------------+-------------------------------------------------------------------------------------------------+
| *width***x***height***\!**                      | Ширина и высота заданы явно, исходное соотношение сторон игнорируется.                          |
+-------------------------------------------------+-------------------------------------------------------------------------------------------------+
| *width***x***height***\>**                      | Уменьшает изображение, если его размер(ы) **больше** указанных ширины и/или высоты.             |
+-------------------------------------------------+-------------------------------------------------------------------------------------------------+
| *width***x***height***\<**                      | Увеличивает изображение, если его размер(ы) **меньше** указанных ширины и/или высоты.           |
+-------------------------------------------------+-------------------------------------------------------------------------------------------------+
| *area***\@**                                    | Изменяет размер изображения до указанной площади в пикселях. Соотношение сторон сохраняется.    |
+-------------------------------------------------+-------------------------------------------------------------------------------------------------+
| *x***\:***y*                                    | Здесь x и y обозначают соотношение сторон (например, 3:2 = 1.5).                                |
+-------------------------------------------------+-------------------------------------------------------------------------------------------------+
| *x***:***y***^**                                | Удаляет строки или столбцы для достижения заданного соотношения сторон.                         |
+-------------------------------------------------+-------------------------------------------------------------------------------------------------+
| *x***:***y***\#**                               | Добавляет строки или столбцы для достижения заданного соотношения сторон.                       |
+-------------------------------------------------+-------------------------------------------------------------------------------------------------+
| **{***size***}{***offset***}**                  | Указание смещения (по умолчанию *+0+0*). Ниже *{size}* относится к любой из вышеуказанных форм. |
+-------------------------------------------------+-------------------------------------------------------------------------------------------------+
| **{***size***}{***+-***}***x***{***+-***}***y*  | Горизонтальное и вертикальное смещения x и y, указанные в пикселях.\                            |
|                                                 | Знаки обязательны для обоих.\                                                                   |
|                                                 | Смещения зависят от опции _-gravity_[^gravity].\                                                |
|                                                 | Смещения не зависят от _%_ или других операторов размера.\                                      |
|                                                 | Обратите внимание, что положительные смещения _X_ и _Y_\                                        |
|                                                 | направлены внутрь к центру изображения для всех опций _-gravity_,\                              |
|                                                 | кроме 'Center'.\                                                                                |
|                                                 | Для 'East' _+X_ --- влево. Для 'South' _+Y_ --- вверх.\                                         |
|                                                 | Для 'SouthEast' _+X_ --- влево и _+Y_ --- вверх.\                                               |
|                                                 | Для 'Center' используется обычное направление _X_ и _Y_\                                        |
|                                                 | (_+X_ --- вправо, _+Y_ --- вниз).                                                               |
+-------------------------------------------------+-------------------------------------------------------------------------------------------------+

: Указание [размеров изображения](https://imagemagick.org/script/command-line-processing.php#geometry) для утилит _ImageMagick_ (далее показаны на примерах). {tbl-colwidths="[20,80]"}

[^фактическое]: Фактическое поведение может варьироваться в зависимости от различных опций и настроек.
[^gravity]: Подробности для опции _-gravity_ см. в [руководстве по программе](https://imagemagick.org/script/command-line-options.php#gravity).

#### _Отступление_ об экранировани символов {.unnumbered .unlisted}

Особенности экранирования аргументов команд в командной строке в [Windows](https://learn.microsoft.com/en-us/windows-server/administration/windows-commands/cmd#remarks) и [Linux](https://www.gnu.org/software/bash/manual/html_node/Quoting.html). Помимо обычных символов перенаправления потоков (`>`, `<`, `|`) в Windows особое значение имеют символы: `^`, `%` (`^` используется для экранирования других символов, а `%` используется для разыменования переменных). Они могут быть использованы в качестве аргументов следующим способом: там где нужен `%` надо писать `%%`, а `^` должен быть экранирован кавычками, иначе будет проигнорирован. В Linux особые символы `!`, `(`, `)`, `\`; для использования в качестве аргументов они должны быть экранированы либо кавычками, либо с помощью `\`; и сам символ `\` тоже должен быть экранирован как `\\`. Также, в Windows и Linux одинарные и двойные кавычки имеют противоположную роль: в Linux одинарные кавычки более "сильные", чем двойные; в Windows наоборот. Поэтому при использовании в Windows команд из мира Linux надо заменять `'` на `"`, и наоборот.

См. также пункт [Ограничения командной строки windows](#ограничения-командной-строки-windows).

#### Примеры

Конвертация всех _jpg_ в меньшее качество --- _75_ (по умолчанию 92), задать имена выходных файлов как _\*-converted.jpg_: *CHEKME:*
```cmd
magick convert -quality 75 -set filename: "%t" "%[filename:fname]-converted.jpg" *.jpg
magick convert -quality 75 -set filename:fname "%t" "%[filename:fname]-converted.jpg" *.jpg
```

Отмасштабировать картинки с сохранением _aspect ratio_:
```cmd
mogrify -resize 50%% *.png
```
```cmd
mogrify -resize 1920x1080 *.png
```
Без сохранения соотношения сторон (здесь кавычки для экранирования символа `!`, который в некоторых терминалах имеет специальное значение):
```cmd
mogrify -resize "1920x1080!" *.png
```

Конвертация всех изображений из папки _images_ в _jpeg_ формат, с масштабированием всех картинок в размер 1920 пикселя по ширине, с сохранением в папку _images-transformed_:
```cmd
magick convert images -resize 1920x JPEG:images-transformed
```

Обрезать рамки одного цвета по краям картинки, уменьшить, и добавить рамку белого цвета шириной 8 пикселей (опция _+repage_ для обновления внутренней системы координат _png_ при обрезке):
```cmd
mogrify -trim -resize 50%% -bordercolor white -border 8x8 +repage *.png
```

Обрезать под заданный размер равномерно к центру, который смещён от геометрического центра на заданную величину (это кадрирование под нужный размер):
```cmd
mogrify -gravity Center -crop 1920x1080+40+100 +repage *.png
```

Отмасштабировать в размер 1920x1080 с сохранением пропорций, недостающие поля нарастить белым цветом от центра (для прозрачности использовать _none_), указать тип [_png_ палитры цветов](https://www.w3.org/TR/png/#table111) Truecolor без прозрачности (для палитры с прозрачностью задать _6_):
```cmd
mogrify -resize 1920x1080 -background white -gravity Center -extent 1920x1080  +repage -define 'png:color-type=2' *.png
```

Скомпоновать картинки в _pdf_:
```cmd
magick *.jpg output.pdf
```

#### Анимированный gif

Собрать все картинки в текущей директории в анимированный _gif_. Опция _-delay_ задаёт частоту кадров в форматах: _N_ по 10 миллисекунд, или, _KxL_: _L_ кадров на _K_ секунд. По умолчанию _-delay 1_ --- 100 кадров в секунду, но эта величина зависит от версии ImageMagick, поэтому лучше указывать её явно.

```cmd
magick -delay 5 *.jpg movie.gif
```
```cmd
magick -delay 1x20 *.png movie.gif
```

### ffmpeg

[**ffmpeg**](https://www.ffmpeg.org/) --- программа командной строки для создания, записи, конвертации, и проигрывания видео и аудио файлов.

Установка:
```cmd
scoop install ffmpeg
scoop install handbrake-cli
```

#### Создание видео из кадров

Создать видео из набора кадров , _"velmagfield-%04d.png"_ --- шаблон входных файлов:
```cmd
ffmpeg -framerate 20 -i "velmagfield-%04d.png" -r 20 -hide_banner -c:a copy -c:v libx264 -crf 18 ^
       -profile:v main -tune animation -preset veryslow -vf format=yuv420p,scale=-1:1080 ^
       velmagfield.mp4
```
[Применяемые опции](https://trac.ffmpeg.org/wiki/Encode/H.264):

* `-framerate 20` --- задать частоту "кадров" входного потока _png_ изображений (соответствует шагу по времени 0.05 секунды);
* `-r 20` --- задать частоту кадров выходного видео;
* `-vf scale=-1:1080` --- отмасштабировать видео до *1080p*; результирующее разрешение должно делиться на два;
* `-c:a copy -c:v libx264` --- задают аудио и видеокодеки, в данном случае аудиокодек будет отсутствовать (он скопирован из входных изображений, где его нет), видеокодек --- *H.264*;
* `-crf 18` --- задаёт качество картинки видео (в ущерб размеру); по умолчанию _23_, _17_ --- видео неотличимо от исходных изображений;
* `-preset veryslow` --- кодировать видео с особой тщательностью, в ущерб времени; другие варианты: medium, fast, slow;
* `-vf format=yuv420p` или `-pix_fmt yuv420p` --- кодировать видео в [цветовое пространство "4:2:0"](https://trac.ffmpeg.org/wiki/Encode/H.264#Encodingfordumbplayers), а не в современный вариант "4:4:4", тогда полученное видео должно проигрываться в PowerPoint и других устаревших плеерах;
* формат выходного файла определяется его расширением; при этом, размер файла практически не зависит от расширения.

Чтобы видео загружалось в _Telegram_ как видео, а не GIF, необходимо, чтобы в нём был аудиопоток^[<https://awesomeprogrammer.com/blog/2023/01/15/how-to-force-telegram-to-upload-mp4-as-mp4-and-not-gifs/>]; закодировать видео с добавлением беззвучного аудиопотока^[<https://stackoverflow.com/questions/12368151/adding-silent-audio-in-ffmpeg#answer-18700245>] и всеми настройками совместимости с _TG_^[<https://stackoverflow.com/questions/38702981/which-video-format-is-right-for-sendvideo-method-in-telegram-bot-api/77255128#77255128>]:
```cmd
ffmpeg -framerate 20 -i "velmagfield-%04d.png" -f lavfi -i aevalsrc=0 -hide_banner -r 20 ^
       -max_muxing_queue_size 9999 -c:v libx264 -crf 18 -maxrate 4.5M -preset medium ^
       -flags +global_header -pix_fmt yuv420p -profile:v baseline -movflags +faststart ^
       -c:a aac -ac 2 -map 0:v -map 1:a -shortest velmagfield.mp4
```

_Note:_ У _ffmpeg_ очень много опций: `ffmpeg --help full`, поэтому задавать специфические характеристики видео достаточно сложно. Для упрощения кодирования видео есть несколько графических оболочек для _ffmpeg_: [handbrake](https://handbrake.fr/), [ffmpeg_batch](https://github.com/eibol/ffmpeg_batch), [clever-FFmpeg-GUI](https://www.videohelp.com/software/clever-FFmpeg-GUI). Они могут ровно то, что может _ffmpeg_, а именно: переконвертация видео в другой кодек, другое разрешение, кадрирование, обрезка по времени, но в графическом интерфейсе. Эти приложения могут быть установлены с помощью [_Scoop_](https://scoop.sh/#/apps) или [_Winget_](https://winstall.app/).

По [ссылке](https://gist.github.com/denius/69d0ea95b9977fd2c0ea289abba3fd63) приведён итоговый скрипт для создания видео из набора _png_ картинок.


#### _Отступление:_ Создание видео в древнем avi формате {.unnumbered .unlisted}

Это устаревший способ кодирования видео, и он вам не потребуется; нужен только на старых серверах.

При таком варианте кодирования размер изображений должен быть кратным 16, этого можно добиться, либо округлив размер до 16 и перекодировать в него, либо сразу перекодировать в разрешение 1920x1072.

Вычислить размер изображения кратный 16 пикселям в большую сторону:
```cmd
magick convert 0000.png  -format '%[fx:16*int((w+15)/16)]x%[fx:16*int((h+15)/16)]' info:
```

Отмасштабировать в размер 1920x1072 с сохранением пропорций, недостающие поля нарастить белым цветом от центра (для прозрачности использовать _none_), указать тип [_png_ палитры цветов](https://www.w3.org/TR/png/#table111) Truecolor без прозрачности (для палитры с прозрачностью задать _6_):
```cmd
mogrify -resize 1920x1072 -background white -gravity Center -extent 1920x1072  +repage -define 'png:color-type=2' *.png
```

И создать древний avi:
```cmd
png2yuv -f 20 -Ip -j '%04d.png' | yuv2lav -b 2048 -o export.avi
```

Который можно перекодировать в видео с кодеком поновее, в *mpeg4* или *H.264*:
```cmd
HandBrakeCLI --preset "Production Standard" --encoder mpeg4 -i export.avi -o export.mp4
```
```cmd
HandBrakeCLI --preset "Production Standard" --encoder x264 -i export.avi -o export.mp4
```


{{< pagebreak >}}

# **_Этап 3: Сложные нужные программы_** {.unnumbered}

# Инженерные программы

## OpenFOAM

[**OpenFOAM**](https://openfoam.org/)

Онлайн книжка по OpenFOAM --- [Notes on Computational Fluid Dynamics: General Principles (2022) C. Greenshields, H. Weller](https://doc.cfd.direct/notes/cfd-general-principles/index).

OpenFOAM будет запускаться из docker-контейнера из под WSL. В такой комбинации: OpenFOAM сможет работать в параллельном режиме, будет запускаться [ParaView](https://www.paraview.org/) без X-сервера в нативном WSL2 графическом режиме.

Дальше предполагается, что _DockerDesktop_ уже запущен.

Устанавливается с помощью docker из каталога [openfoam](https://hub.docker.com/u/openfoam), например^[Скачивает 1.5&nbsp;ГБ, займёт 3&nbsp;ГБ]:
```cmd
docker pull openfoam/openfoam11-paraview510:latest
```

Установка: в WSL скачивается запускающий _OpenFOAM_ скрипт из официального каталога <http://dl.openfoam.org/docker/> и настраивается; для этого выполнить следующие команды в WSL терминале (открывается командой `wsl`, или в профиле WSL в WT/Conemu/Cmder):
```sh
mkdir -p $HOME/software
cd $HOME/software
wget http://dl.openfoam.org/docker/openfoam11-linux
sudo mkdir -p /usr/local/bin
sudo cp openfoam11-linux /usr/local/bin
sudo chmod a+x /usr/local/bin/openfoam11-linux
exit
```

Запуск OpenFOAM: выполнить из любого терминала:
```cmd
cd some-project-dir
wsl openfoam11-linux -x
```

_Note:_ если изначально OpenFOAM не был закачен с помощью _docker pull ..._, то OpenFOAM будет загружен при первом запуске, но при этом не будет прогресс-бара.

_Note:_ скрипт запуска _openfoam11-linux_ имеет небольшой баг: после его запуска и выхода, запуск в этом же терминале `wsl` (без параметров) будет произведён в последней mount-point OpenFOAM контейнера; это абсолютно ни на что не влияет, просто к сведению.

## ParaView

Нативный [**ParaView**](https://www.paraview.org/), который умеет применять аппаратное ускорение видеоадаптера (OpenGL), должен быть побыстрее, чем встроенный в _OpenFOAM_. [Установить](https://winstall.app/apps/Kitware.ParaView) (долго скачивает!):
```cmd
winget install --id=Kitware.ParaView -e
```

## FreeCAD

[**FreeCAD**](https://www.freecad.org/features.php) --- opensource CAD программа. Использование разделяется на режимы, в зависимости от выбранного [Workbench](https://wiki.freecad.org/workbenches): есть режимы создания 2D чертежа (Draft&Sketcher), два режима создания 3D деталей ([Part&PartDesign](https://wiki.freecad.org/Part_and_PartDesign)), сборки геометрии ([Assembly](https://wiki.freecad.org/Assembly_Workbench)), создания сетки с помощью GMSH ([Mesh](https://wiki.freecad.org/Mesh_Workbench)), создание и решения задач МКЭ ([FEM](https://wiki.freecad.org/FEM_Workbench)). Все эти возможности показаны в соответствующих [туториалах](https://wiki.freecad.org/Tutorials#Tutorials_-_Comprehensive_list).

[Установка](https://winstall.app/apps/FreeCAD.FreeCAD):
```cmd
winget install --id=FreeCAD.FreeCAD -e
```

Настройка:

* режиму навигации мышкой продуктов Ansys соответствует режим _Blender_ во FreeCAD
* цветовая схема _FreeCAD Light_ самая разборчивая.

## Blender

*\<TBD\>*

```cmd
winget install --id=BlenderFoundation.Blender -e
```

## 3D reverse engineering

*\<TBD\>*

<https://alternativeto.net/software/geomagic-design-x/>

[**CloudCompare**](https://www.danielgm.net/cc/), [about](https://alternativeto.net/software/cloudcompare/about/).

**MeshLab** --- <https://www.meshlab.net/>, [about](https://alternativeto.net/software/meshlab/about/). The open source system for processing and editing 3D triangular meshes.\
It provides a set of tools for editing, cleaning, healing, inspecting, rendering, texturing and converting meshes. It offers features for processing raw data produced by 3D digitization tools/devices and for preparing models for 3D printing.

See also <https://github.com/topics/3d-reconstruction>


# Математика

## Калькулятор!

[**Qalculate!**](https://qalculate.github.io/screenshots.html) --- калькулятор с широчайшими возможностями: единицы измерения, интервальная арифметика, полиномы, решение уравнений, простое дифференцирование и интегрирование, матрицы и вектора! [Примеры вычислений](https://github.com/Qalculate/libqalculate/#examples-expressions).

[Установка](https://winstall.app/apps/Qalculate.Qalculate):
```cmd
winget install --id=Qalculate.Qalculate -e`.
```

## Matlab аналоги

### Scilab

[**Scilab**](https://www.scilab.org/about/scilab-open-source-software) --- [открытый](https://gitlab.com/scilab/scilab) программный комплекс, полноценная замена Matlab. Есть встроенный аналог Simulink --- [Xcos](https://www.scilab.org/software/xcos). Установка:
```cmd
winget install --id=Scilab.Scilab -e
```

### Octave

[**Octave**](https://octave.org/) --- простая среда для разработки и отладки Matlab программ. Simulink не поддерживается.
```cmd
scoop install octave
```

## SageMath

[**SageMath**](https://www.sagemath.org/tour.html) --- opensource программа для символьной математики, альтернатива Mathcad, Mathematica.

Устанавливается с помощью docker из репозитория <https://hub.docker.com/r/sagemath/sagemath>^[размер скачиваемого образа 1.5&nbsp;Гбайт]:
```cmd
docker run --name sage -p8888:8888 sagemath/sagemath:latest sage-jupyter
```

В консоли появится сообщение вида
```txt
To access the server, open this file in a browser:
        ...
    Or copy and paste one of these URLs:
        http://127.0.0.1:8888/tree?token=
```
По этой ссылке будет доступно запущенное SageMath приложение. В нём создать новую сессию: кнопка _New_ справа сверху, из выпадающего списка выбрать SageMath. Созданный Jupyter NoteBook после работы сохранить в виде .ipynb файла, и скачать (_Download_) в файловом менеджере на первой странице, чтобы сохранить копию в своих папках, помимо сохранённой версии в docker контейнере.

В последующем, для запуска _SageMath_ набирать столь сложную команду не потребуется: контейнер можно будет запускать либо из интерфейса _DockerDesktop_, либо из командной строки командой `docker start sage` (см. [_Управление Docker_](#управление-dockerом)).

## Maxima

Ещё есть *CAS (Computer Algebra Systems)* программа для символьной математики [**Maxima**](https://maxima.sourceforge.io/)/[**WxMaxima**](https://github.com/wxMaxima-developers/wxmaxima), использование которой [достаточно](https://maxima.sourceforge.io/documentation.html) [не тривиально](https://wxmaxima-developers.github.io/wxmaxima/wxmaxima.pdf), но это, возможно, [наилучшая открытая _CAS_](https://en.wikipedia.org/wiki/List_of_computer_algebra_systems).
```cmd
scoop install extras/maxima
```

Дополнительно, можно установить чуть более новый GUI со страницы [wxMaxima-developers](https://github.com/wxMaxima-developers/wxmaxima/releases).

## Построение графиков

### LabPlot
[labplot.kde.org](https://labplot.kde.org/)\
Открытая программа для построения графиков по табличным данным, альтернатива Origin/Grapher. Понимает [Markdown](https://ru.wikipedia.org/wiki/Markdown) и [LaTeX](https://en.wikibooks.org/wiki/LaTeX/Mathematics) формулы; умеет загружать данные напрямую из Jupyter Notebook, включая Python, Julia, Maxima. Умеет _Digitization_ картинок --- вытаскивать данные из графиков с картинок.
```cmd
winget install --id=KDE.LabPlot -e
```

### Veusz
[veusz.github.io](https://veusz.github.io/examples/)\
Простая программа для построения графиков по табличным данным.
```cmd
scoop install extras/veusz
```

### Matplotlib

[matplotlib.org](https://matplotlib.org/stable/plot_types/index.html)\
Библиотека для Python и C++ для построения графиков, удобна для постоянных пользователей Python; [установка](https://matplotlib.org/stable/install/index.html):
```cmd
python -m pip install -U matplotlib
```

Пример использования библиотеки _matplotlib_ из C++ ([отсюда](https://discourse.julialang.org/t/plot-of-a-function-from-x-0-to-x-1-is-not-shown/128091)):

```C++
// (c) 2025 https://discourse.julialang.org/u/Freya_the_Goddess

// g++ main.cpp -o main -std=c++11 -I/usr/include/python3.9 -lpython3.9 -DWITHOUT_NUMPY
// g++ main.cpp -o main -std=c++11 -lpython3.9 -I/usr/include/python3.9 -I/usr/lib/python3.9/site-packages/numpy/core/include

#include "matplotlibcpp.h"
#include <cmath>

namespace plt = matplotlibcpp;

int main()
{
    // Prepare data
    int n = 1000;
    double xl = 0.0, xh = 10.0;
    std::vector<double> x(n), y(n), z(n);

    for(int i=0; i<=n; ++i)
    {
        x.at(i) = xl + i*(xh-xl)/n;
        y.at(i) = pow(1.0 / pow(x.at(i) - 1.0, 2.0), 1.0/3.0);
    }

    // Set the size of output image to 1200x780 pixels
    plt::figure_size(1200, 780);
    // Plot line from given x and y data. Color is selected automatically.
    plt::plot(x, y);
    // Plot a line whose name will show up as "x exp(-x)" in the legend
    plt::named_plot("1/(x-1)^(2/3)", x, y);
    // Set x-axis to interval [0,10]
    plt::xlim(xl, xh);
    // Add graph title
    plt::title("Plot of 1/(x-1)^(2/3)");
    // Enable legend.
    plt::legend();
    plt::show();
    // Save the image (file format is determined by the extension)
    // plt::save("basic.png");
}
```

Тоже самое на Python:

```{python}
#| warning: false
import numpy as np
import matplotlib.pyplot as plt

n = 1000
xl = 0.0; xh = 10.0
x = np.linspace(xl, xh, n)
#y = np.power(x - 1, -2 / 3)
y = np.power(1 / (x - 1)**2, 1/3)

# plot 12 by 7.8 inches size at default 100 DPI gives 1200 by 780 picture
# but for Quarto inline-pic there is should be real size:
#plt.figure(figsize=(12, 7.8))
plt.figure(figsize=(8, 6))

plt.plot(x, y, label="1/(x-1)^(2/3)")

# Set x-axis to interval [0,10]
plt.xlim(xl, xh)

plt.title("Plot of 1/(x-1)^(2/3)")

plt.legend()
#plt.show()
plt.savefig("basic-python.png")
```

![](basic-python.png)


### Julia

Для построения графиков на Julia существует множество пакетов, наиболее распространённый из них это [Plots.jl](https://github.com/JuliaPlots/Plots.jl). Документацию по параметрам отображения графиков можно найти на страницах документации: [общие атрибуты](https://docs.juliaplots.org/stable/generated/attributes_series/), [оси](https://docs.juliaplots.org/stable/generated/attributes_axis/), [параметры изображения](https://docs.juliaplots.org/stable/generated/attributes_plot/) и другие. Далее представлен код для построения графика аналогичного вышеприведённым.

```{julia}
#| echo: fenced
using LaTeXStrings
using Plots
import Plots:mm

n = 1000
xl = 0.0
xh = 10.0

x = LinRange(xl, xh, n)

y = (1 ./ (x .- 1).^2).^(1/3)

# explicit init GR backend of Plots.jl
gr(size=(700,500))

plot(x, y,
     label=L"$\frac{1}{x-1}^{2/3}$",
     title=L"Plot of $1/\left(x-1\right)^{2/3}$", # also can be `:none`
     xlims=(xl, xh),
     xlabel=L"$x$",
     ylabel=L"$y$",
     legend=:topright,  # by default `:best`
     #size=(700,500),   # picture size in pixels (width x height)
     #size=(1200,780),   # picture size in pixels (width x height)
     #dpi=96,            # picture DPI
     #margin=10mm,
     left_margin=8mm,
     bottom_margin=8mm,
     linewidth=3,
     #markersize=8,
     #markerstrokewidth=2,
     legendfontsize=14,
     guidefontsize=14,
     titlefontsize=18,
     tickfontsize=14,
     #grid=true,              # enable grid
     #gridalpha=0.5,          # grid transparency
     #gridlinewidth=1.5,      # grid thickness
     #minorgrid=true,         # enable secondary grid
     #minorgridalpha=0.3,     # secondary grid transparency
     #minorgridlinewidth=1.0, # secondary grid thickness
     framestyle=:box
)

#savefig("basic-julia.png")
```


### Gnuplot

[www.gnuplot.info](http://www.gnuplot.info/)\
Консольная программа для построения графиков с широкими возможностями. [Примеры](http://www.gnuplot.info/demo_6.0/), [обзор на русском](https://habr.com/ru/companies/ruvds/articles/517450/).
```cmd
scoop install gnuplot
```

Пример построения изображения графика на gnuplot. Этот фрагмент кода необходимо сохранить в файл, например _sample-plot.gp_, и выполнить команду `gnuplot sample-plot.gp`.

```default
# set the image size (in pixels)
set terminal pngcairo size 1200,780 enhanced font 'Verdana,18'

# save the plot to a file
set output 'basic.png'

# set the plot title
set title "1/(x-1)^{2/3}"

# set axis ranges
set xrange [0:10]  # Set x-axis range from 0 to 10
set yrange [*:*]   # Automatically determine y-axis range. The `[*:*]` is the default behavior.

# enable the legend
set key box

set border linewidth 2

# plot the function
plot [0:10] (1.0/(x - 1.0)**2)**(1.0/3.0) title "1/(x-1)^{2/3}" with lines linewidth 3 linecolor rgb "blue"
```


```{julia}
#| echo: false
using Dates

gnuplot_script = """
# set the image size (in pixels)
set terminal pngcairo size 1200,780 enhanced font 'Verdana,18'

# save the plot to a file
set output 'basic-gnuplot.png'

# set the plot title
set title "Plot of 1/(x-1)^{2/3}"

# set axis ranges
set xrange [0:10]  # Set x-axis range from 0 to 10
set yrange [*:*]   # Automatically determine y-axis range. The `[*:*]` is the default behavior.

# enable the legend
set key box

set border linewidth 2

# plot the function
plot [0:10] (1.0/(x - 1.0)**2)**(1.0/3.0) title "1/(x-1)^{2/3}" with lines linewidth 3 linecolor rgb "blue"
"""

filename = "temp_$(now()).gp"
open(filename, "w") do io
    write(io, gnuplot_script)
end
run(`gnuplot $filename`)
rm(filename)
```

![](basic-gnuplot.png)

Более сложный пример построения графика в gnuplot с обработкой данных из файла и построением двойной оси _Y_:

```default
scale = 2.0

set terminal pngcairo size 640*scale,480*scale fontscale scale linewidth scale pointscale scale
set output 'report-water-height.out.png'
set nokey

# setting up graph axes properties
set border 1+2+4+8 lw 4
set xtics border mirror in scale 1, 0
set ytics border mirror in scale 1, 0
set mxtics  5
set mytics  5

# setting up graph grid properties
set grid xtics ytics  mxtics mytics lt 1 lw 1 lc rgb "black", lt 1 lw 0 lc rgb "black"

# some specific function for data processing
fun1(x) = 0.00142635 + 0.698578*x - 0.913872*x**2 + 0.75045*x**3 - 0.302874*x**4 + 0.0593173*x**5 - 0.00438143*x**6

# set up second Y-axis with values `40 - i`, where `i` is corresponds the first Y-axis
do for [i=-100:100:2] { set y2tics add (sprintf("%g",i) 40.0-i) }

# `$3` and `$2` tells it to use the data from the third and second columns of data-file
# `every ::3` specifies to plot the graph skipping the first three rows of data
plot [:][:] 'report-water-mass.out' using ($3):( (1.01 - fun1($2/1000.0)) / 0.0254 ) every ::3 with lines lw 3 lc rgb "blue"
```

Файл с данными _report-water-mass.out_ имеет следующий вид
```txt
"report-def-0-rfile"
"Time Step" "report-def-0 etc.."
("Time Step" "report-def-0" "flow-time")
0 1907.704977059886 0
10 1703.23047212398 0.5
20 1752.389260134199 1
30 2163.713605058183 1.5
40 2384.578894811974 2
50 2556.318405498912 2.5
60 2655.06514863053 3
70 2722.175536462764 3.5
80 2743.568186672038 4
90 2716.455743643943 4.5
100 2613.660462368277 5
110 2527.183466538219 5.5
120 2466.08010246078 6
130 2360.274092810494 6.5
140 2315.101811862138 7
150 2430.425040697297 7.5
160 2581.324755366251 8
170 2677.462160156302 8.5
180 2788.573315838712 9
190 2842.559141891374 9.5
200 2825.030621610734 10.00000000000001
210 2672.220368620244 10.5
220 2468.360142802453 11
```


{{< pagebreak >}}


# **_Этап 4: Сложные ненужные программы_** {.unnumbered}

# _Приложение:_ AI/LLM

_Note:_ В этой главе в основном говорится про работу с локальными моделями _LLM_ --- которые хранятся и запускаются непосредственно на компьютере. Но, все приведённые принципы работы верны и для онлайн моделей.

## Введение

[Большие языковые модели](https://ru.wikipedia.org/wiki/Большая_языковая_модель) ([Large Language Models](https://en.wikipedia.org/wiki/Large_language_model), LLM), это искусственные нейронные сети (НС) типа [трансформер](https://en.wikipedia.org/wiki/Transformer_(deep_learning_architecture)), обученные на больших объёмах данных. LLM понимают естественные языки, и генерируют ответы на них; содержат в себе большой объём связной информации, на основе которой строят ответы; имеют способности к размышлению в виде построения логических цепочек, в том числе дополнения, интерполяции, ассоциации последовательностей слов; умеют работать с текстами: переводить, анализировать на связность, непротиворечивость, рецензировать, и, создавать новые тексты по запросу. Помимо работы с естественными языками работают с языками программирования и другими искусственными языками: программируют, ищут баги, создают коды для станков с ЧПУ. Специально обученные сети работают с графической информацией: распознавание изображений и видео, OCR, генерация и/или модификация изображения и видео. Аналогично, работают и с аудио-информацией, в частности распознавание и генерация речи, генерация музыки. Могут выступать в качестве управляющего контура для роботов и станков, и в качестве автопилотов.

Несколько упрощённо работу нейросети-трансформера можно описать как манипуляции над цепочкой точек ([эмбеддингов](https://en.wikipedia.org/wiki/Word_embedding)^[см. [описание алгоритма](#алгоритм-работы-нейросети-трансформера) в конце главы]) в многомерном^[типичная размерность 512] [семантическом пространстве](https://en.wikipedia.org/wiki/Semantic_space)^[Каждая точка-эмбеддинг представляет собой короткий вектор из floating-point величин, и над последовательностью таких векторов проводятся алгебраические операции.]. В таком семантическом пространстве близкие понятия находятся на небольшом расстоянии друг от друга; в этом пространстве работают _разностные отношения_ (_difference relations_): "Король - Мужчина = Королева". Поэтому можно утверждать что, языковые модели в самом деле "понимают" информацию с которой работают; что "умеют мыслить", выделяя главное, находя ассоциации, _разностные отношения_, и проч.; умеют находить решения, заполняя лакуны в цепочках эмбеддингов интерполяцией в семантическом пространстве, продляяя цепочки ембеддингов экстраполяцией.

Из характерных особенностей нейронных сетей типа трансформер можно выделить:

* входной текст разбивается на токены --- это минимальные единицы информации для нейросети. Каждому знаку препинания соответствует один токен. Каждому короткому, или общеупотребительному слову соответствует один токен. Сложным или редким словам соответствуют 2, 3 или более, токенов, как правило, по одному токену на корень слова, на приставку, суффикс, окончание, что очень характерно для русского языка, в английском большинство слов это один токен. На выходе из трансформера токены обратно превращаются в текст;

* в процессе работы, на каждой итерации, на выходе из сети в качестве ответа генерируется один токен, который присоединяется в конец цепочки, состоящей, из исходного запроса, и последовательности уже присоединённых в конец токенов ответа, полученных на предыдущих итерациях; после чего пополненная цепочка токенов опять посылается на вход и начинается новая итерация;

* типичная максимальная длина входного контекста --- тысячи и десятки тысяч токенов; длина выходного контекста сравнима с размером входа; но бывает и на порядки больше длины входа у специализированных трансформеров;

* сеть-трансформер обычно состоит из 10-40 двойных слоёв;

* несколько приближённо, но можно сказать, что каждый слой НС представляет собой матрицу^[подробнее в [описании алгоритма](#алгоритм-работы-нейросети-трансформера)], и прохождение информации через слой является операцией умножения этой матрицы на каждый вектор (ембеддинг) из набора, представляющего запрос плюс текущую часть ответа;

* отлично распараллеливается и обучение, и выполнение;

Упрощённое описание алгоритма работы нейросети-трансформера [приведено в конце главы](#алгоритм-работы-нейросети-трансформера).

### Где начать {.unnumbered}

По степени доступности языковые модели [LLM](https://en.wikipedia.org/wiki/List_of_large_language_models) можно разделить на две категории:

* закрытые модели, которые недоступны для загрузки и локального использования;

* модели с открытыми весами, которые предоставляют возможность загрузки и запуска на локальных вычислительных ресурсах. Большинство из открытых моделей доступны к загрузке с сайтов <https://huggingface.co/> и <https://ollama.com/>.

И закрытые модели, и модели с открытыми весами, одинаково доступны в качестве онлайн-сервисов. Среди них есть сервисы с бесплатным доступом, есть с платным, и, большинство онлайн-сервисов имеют гибридный тип доступа.

Среди наиболее популярных бесплатных онлайн-сервисов LLM, доступных из России, это GigaChat <https://giga.chat/> от Сбера и YandexGPT <https://ya.ru/ai/gpt>, и, китайские DeepSeek <https://chat.deepseek.com/> и Qwen <https://chat.qwen.ai/> от Alibaba. Все эти онлайн-сервисы бесплатны только в конечном количестве запросов (в сутки), при превышении которого потребуется оплата. Доступ по API для ИИ ассистентов, агентов, RAG, и пр. доступен только за плату.

_Note:_ Конечно, возникает естественный вопрос, а зачем тогда платить, если есть возможность скачать и запустить модели самостоятельно? Причина в том, что объём современных сильных моделей составляет сотни гигабайт^[[DeepSeek](https://huggingface.co/deepseek-ai) --- 1.4ТБ, [Qwen3](https://huggingface.co/Qwen) --- 480ГБ], и никакой персональный компьютер их не сможет нормально запустить; причём, покупка и эксплуатация необходимой для LLM вычислительной инфраструктуры выйдет много дороже, чем использование платных онлайн LLM сервисов.



## PROMPTS

На данный момент основной формой работы с LLM является диалог (чат). Другие варианты взаимодействия, такие как ИИ-помощники для программирования и написания текстов, агенты, являются слишком сложными в настройке программного обеспечения, имеют санкционные ограничения с доступом, и, наконец, все эти возможности требуют, либо оплаты онлайн сервисов LLM, либо больших вычислительных ресурсов для своего использования.

При работе в диалоге с LLM на первый план выходят вопросы (запросы, prompts) к LLM: в зависимости от того, насколько точно человек сможет сформулировать описание задачи и задать вопрос, настолько адекватно и точно модель будет отвечать. Модель может несколько "догадываться" о контексте, о неявной части вопроса, но не стоит на это рассчитывать, и, следует _явно_ и _точно_ формулировать запросы.

### Примеры запросов к ЯМ/LLM

Для выполнения задач надо прямо в лоб на русском спрашивать:

```md
Напиши программу для параллельного умножения матрицы размером MxN на вектор
с использованием MPI на языке Fortran. Последовательно объясни действия процедур.
```

```md
Напиши программу для интегрирования задачи трёх тел на примере Солнца, Юпитера и
Земли методом Адамса-Башфорта на Python. Последовательно объясни действия функций.
```

```md
Как на github создать PR в чужой проект, если у меня уже есть форк
этого проекта со внесёнными мной коммитами и мержами апстрима?
```

```md
Как настроить VSCode для компиляции и отладки программ на языке Fortran?
```

```md
Аккуратно сконвертируй информацию с приложенного pdf
в размеченный Markdown код, **сохраняй форматирование**.

@article-with-formulas.pdf
```

```md
Переведи на английский язык текст начиная со следующего абзаца,
выведи только перевод, сохраняй форматирование.

Ехали медведи\
На велосипеде.\
А за ними кот\
Задом наперёд.\
А за ним комарики\
На воздушном шарике.
```

```md
Тщательно переведи на русский язык **каждую строчку** прикреплённого справочника.

@Reference.md
```

```md
Оформи в виде Markdown таблиц прикреплённый справочник.

@Справочник.md
```

```md
Скомбинируй два прикреплённых справочника в виде Markdown таблиц из трёх колонок,
где в первой колонке будет общая первая колонка, во второй колонке будет описание
на русском, и в третьей колонке будет описание на английском.

@Справочник.md, @Reference.md
```

```md
Напиши скрипт на Julia для интегрирования массы, методом трапеций, по данным из файла:

- исходные данные для интегрирования во второй колонке файла, поток массы, в [kg/s];
- соответствующие временные метки в третьей колонке, в [s];

Как результат работы, скрипт должен отправлять на консоль данные построчно.
В каждой строке должны выводиться следующие величины, разделённые пробелами:

1. порядковый номер;
2. суммарная, накопленная к этому моменту масса, в [gramm];
3. момент времени, [s].

Комментарии в скрипте должны быть на английском языке.

Отдельно поясни работу скрипта на русском языке.
```

```md
Напиши скрипт, на Python с использованием PyTorch, для обучения нейросети MLP
(Feedforward) для аппроксимации (регрессии) функции одного double параметра
от нескольких входных double аргументов.

- Задаваемые параметры, это: Re, alpha, ta_u, ta_l, tb_u, tb_l, alpha_c, alpha_b.

- Искомые (аппроксимируемые) параметры для регрессии, это: Cl, Cd, Cm, Cp.

- Исходные данные были заранее вычислены и сохранены файле CSV
  (dataset_random-20250604-121627.csv.xz), с заголовком следующего вида:
  "Re,alpha,ta_u,ta_l,tb_u,tb_l,alpha_c,alpha_b,Cl,Cd,Cm,Cp"

- В скрипте требуется явно разделить входную выборку из CSV на данные
  для обучения, и данные для проверки.

Искомые параметры должны обрабатываться по отдельности --- в скрипте
должна производиться работа только с одной величиной (скажем Cl),
и в результате должна получаться одна MLP сеть. Для получения других MLP сетей
от других величин я, в дальнейшем, самостоятельно заменю все вхождения Cl
в скрипте на другие величины.

В скрипте необходима процедура сохранения полученной MLP в общеупотребительный
формат хранения нейросетей PyTorch для дальнейшей загрузки и использования.
```

```md
Добавь в приведённый код ускорение обучения и применения на GPU Nvidia.
```

Для улучшения качества ответов связанных с математикой, к запросу следует добавлять фразу вида:

```md
Please reason step by step, and put your final answer within \boxed{}.
```
```md
Пожалуйста, рассуждай шаг за шагом, и помести окончательный ответ в \boxed{}.
```


### Структуризация запросов и Markdown


В вышеприведённых примерах используется Markdown разметка `**` для выделения текста, используется обратный слэш (`\`) в конце строк, который в Markdown обозначает перенос строки без начала нового параграфа. Также можно использовать бэктики `` ` `` и ```` ``` ```` для выделения участков кода.

При необходимости, запросы можно записывать в одну строку, в нужных местах вставляя символы `\n` для переноса строки для форматирования; это может потребоваться при работе через командную строку (CLI) или программные интерфейсы (API), когда модели передаётся запрос в виде одной строки текста.

Языковые модели отлично понимают разметку Markdown, поэтому, такую разметку рекомендуется всегда использовать, для усиления акцентов, для форматирования текста с целью лучшей структуризации информации.

Также для усиления акцентов могут использоваться формулы (слова) вежливости, такие как "Пожалуйста", на которые языковые модели превосходно реагируют.

Даже для несложных запросов ответы моделей значительно улучшаются, если запрос должным образом структурирован (см. выше примеры интегрирования методом трапеций и PyTorch). Ещё немаловажный плюс от структурирования запросов в том, что после написания такого запроса у пользователя остаётся хорошо структурированная формулировка решаемой задачи.

За один запрос модель вряд ли сможет выполнить сложную задачу, поэтому такие задачи необходимо разделять на этапы, как в примере со справочником; либо составлять сложные, состоящие из многих пунктов, запросы, с примерами, с критериями, и т.п.; см. далее [Инжиниринг запросов](#инжиниринг-запросов).


### Задание и отображение математических выражений

Все языковые модели при работе с запросами и при выдаче ответов используют Markdown в качестве языка разметки. В Markdown все математические выражения (формулы) записываются с использованием нотаций языка разметки *LaTeX*. Для выделения в тексте формул *LaTeX* используются два типа нотаций. Современная нотация выделения формул использует символы `\(` | `\)` для встроенных (inline math) формул, и `\[` | `\]` для блочных (display math) формул; и устаревшая нотация, введённая ещё Д.Кнутом, использует символы `$` | `$` для встроенных формул, и `$$` | `$$` для блочных, т.е. у устаревшей нотации нет разделения на открывающие и закрывающие выделители формул, что нехорошо в контексте длинных или неточных текстов, где в случае потери только лишь одного символа весь последующий текст становится нечитабельным.

Все онлайн-сервисы, а также большинство программ, используют надёжную современную нотацию выделения формул. Но, в запросах, также, понимают и устаревшую нотацию, которую несколько проще набирать для простых математических выражений.

### Инжиниринг запросов

Для изучения методов составления _экспертных запросов_ можно порекомендовать руководство от Google: [*"Prompt Engineering"*](https://www.kaggle.com/whitepaper-prompt-engineering).

Или в русском переводе, *"Руководство Google по промпт-инжинирингу"*, по разделам:

1. [Основы промпт-инжиниринга и базовые техники](https://habr.com/ru/articles/901426/)
2. [Продвинутые техники промптинга и работа с кодом](https://habr.com/ru/articles/901920/)
3. [Лучшие практики и рекомендации](https://habr.com/ru/articles/902330/)

В приведённом руководстве достаточно подробно рассматриваются большинство аспектов языковых моделей с точки зрения экспертного использования: управляющие опции LLM, составление запросов, цепочки рассуждений, и многое другое.

Изучить данное руководство, или подобное ему, весьма полезно для понимания механизмов работы LLM. Правда, через пару-тройку лет подобные руководства станут неактуальными, так как языковые модели станут достаточно "умными" чтобы понимать людей и без специальных "приёмов" формирования запросов, а для сложных задач будет достаточно подробного *технического задания* (*ТЗ*).

В качестве примера инжиниринга запросов можно рассмотреть ситуацию, когда взаимодействие с LLM заходит в тупик и нужного результата не получается добиться даже с большим количеством уточняющих запросов. В таком случае можно прибегнуть к методу, когда сама модель будет помогать составлять новый запрос анализируя историю чата; для этого ей потребуется запрос вида (цитируется с <https://habr.com/ru/articles/914640/>):

```md
# Роль
Ты - экспертный аналитик промптов, специализирующийся на работе с <...>.

Твоя задача --- провести глубокий анализ всей истории диалога и создать
оптимизированный промпт для получения корректного результата с первой попытки.

# Задача
Проанализируй весь контекст нашего чата от начала до конца, включая:

- Все мои первоначальные запросы
- Все твои ответы и попытки выполнения задач
- Все мои исправления, комментарии и указания на ошибки
- Паттерны проблем, которые повторялись

## Особое внимание удели

- Проблемам с <...>
- Ошибкам в анализе <...>
- Недопониманию контекста или требований
- Техническим ограничениям, которые не были учтены

# Инструкции по анализу
1. Определи корневые причины каждой ошибки или неточности
2. Выяви, какая информация была упущена в исходных промптах
3. Найди паттерны в моих исправлениях - что я систематически добавляю или корректирую
4. Оцени, какие дополнительные контекстные данные нужны для точного выполнения

# Формат результата
Создай новый, улучшенный промпт в следующем формате:


**ОПТИМИЗИРОВАННЫЙ ПРОМПТ:**

[Здесь полный текст нового промпта, готовый к копированию]


**КЛЮЧЕВЫЕ УЛУЧШЕНИЯ:**

- [Перечисли 3-5 основных изменений по сравнению с предыдущими попытками]


**ПРЕДОТВРАЩЁННЫЕ ОШИБКИ:**

- [Укажи конкретные проблемы из истории чата, которые теперь должны быть решены]

# Стиль результата
- Промпт должен быть максимально конкретным и однозначным
- Включи все необходимые технические детали и ограничения
- Предусмотри возможные краевые случаи на основе истории ошибок
- Используй чёткие, недвусмысленные формулировки
```

В запросе необходимо подставить свои формулировки в места `<...>`.

### *Отступление* об особенностях запросов для локальных LLM

В LLM предыдущих поколений качество запроса было критически важно для успешности решения задач. Современные LLM, обученные методом *Reinforcement Learning*, уже не столь сильно зависят от ясности, явности, и однозначности запросов. И тем не менее, все онлайн-сервисы языковых моделей при работе автоматически добавляют к пользовательскому запросу так называемый *системный запрос* (*System Prompt*), который улучшает и структурирует "мыслительную цепочку" языковой модели.

Некоторые коммерческие сервисы открывают свои _системные запросы_; они были собраны, и представлены в библиотеке <https://github.com/elder-plinius/CL4R1T4S>. По текстам системных запросов видно, что, во-первых, они очень объёмные --- десятки килобайт, это многие страницы текста; а во-вторых, что достаточно значительная часть из этих десятков килобайт запроса состоит именно в попытке улучшить структуру мышления модели; остальная часть системного запроса задаёт ограничения на выполнение для безопасности ответов.

При локальном применении LLM некий *системный запрос* тоже добавляется, но он совершенно не столь широк и универсален как системные запросы коммерческих систем, и, часто представляет собой буквально одно предложение вида *"You are AI assistant."*. Посмотреть применяемый в локальной LLM *системный запрос* можно, либо на сайте [*hf.co*](https://huggingface.co/), либо в применяемой программе.

Поэтому, если хочется, чтобы ответы от локальной LLM были столь же качественными, как и ответы от коммерческих сервисов, надо не лениться, и писать хорошие запросы (см. п. [Инжиниринг запросов](#инжиниринг-запросов)), а ещё лучше, добавлять в запрос "шапку", которая будет объяснять модели _как ей следует думать_. Примеры хорошо структурированных запросов (prompts) можно посмотреть в библиотеках запросов, например <https://github.com/0xeb/TheBigPromptLibrary> или <https://github.com/abilzerian/LLM-Prompt-Library>.


## Некоторая классификация открытых языковых моделей

_Note:_ Здесь рассматриваются модели работающие с текстами. Модели работающие с мультимедиа информацией имеют схожие категории, но всё же у них есть своя специфика.

После первичного обучения, когда внутрь LLM поместили весь интернет, возникает, так называемая, _Base_ модель. Эта модель не умеет делать чего-либо определённого, а может только отвечать наиболее вероятными ассоциациями на запросы.

Далее base модель дообучают для той или иной цели.

Для ведения диалогов base модель дообучают на массивных наборах вопрос-ответ, чтобы модель в дальнейшем, по этой аналогии, отвечала на новые вопросы. Такая модель для чата называется _Instruct_ модель, так как она выполняет инструкции --- отвечает на вопросы.

Другой вариант дообучения base моделей состоит в том, что модель учат составлять логические цепочки связанные с запросом. Обучают, опять же, на массивах логических цепочек, таких как математические доказательства, тексты по логике, и т.п. На заключительном этапе такого обучения у модели формируется специальная форма ответа, в процессе которого, модель сначала строит логические цепочки и ассоциации связанные с запросом, которые, возможно, потребуются в ответе; после чего эта информация включается в исходный запрос, и на основе этого пополненного запроса строится полный ответ. Это модели с мышлением, _Reasoning_ модели. Простые instruct-модели без мышления называют _Non-Reasoning_ моделями. При равных размерах, _Reasoning_ модели всегда сильнее простых моделей, но и гораздо медленнее.

Отдельно можно выделить модели обученные и/или дообученные на больших массивах программного кода с упором на логичность, точность и педантичность до самого последнего символа, в ущерб "человечности" диалога и прочих социальных штучек. Такие модели называются _Coder_, _Coding_ и т.п. Основная область применения этих моделей, это работа в составе средств разработки и _Copilot_, для задач автокомплита, написания кода, тестирования, поиска ошибок в коде, написания документации по готовому коду; также могут применяться для поиска логических ошибок в текстах и формулах. _Coder_ модели, это _Non-Reasoning_ модели, заточенные, в первую очередь на точность и скорость; они, конечно, могут написать простую программу по запросу, но если потребуется создание чего-то со сложной математикой или алгоритмами, то coder модели однозначно уступят любой сравнимой по размеру _Reasoning_ модели. (_Note:_ Из-за того, что для продуктивной работы программистов требуется хорошая отзывчивость среды разработки, потребуется большая скорость выполнения LLM, для чего нужны очень мощные вычислительные ресурсы, которые недоступны большинству пользователей; поэтому, скорее всего *в качестве Copilot'а*, эти модели придётся использовать по платной подписке не смотря на их открытость.)

Ещё бывают математические модели, которых дообучали на логике и доказательствах теорем. Они предназначены для проверки уравнений и доказательств, и, для составления новых уравнений и доказательств ---  с проверками справляются, с составлением новых доказательств пока не очень. Называются _Math_, _Proof_, _Prove_ и т.п. Можно сказать, что это _Reasoning_ модели на максималках --- они будут долго и скурпулёзно перебирать разные варианты и гипотезы, либо пока не найдётся верное решение, либо пока не будет достигнута предельная длина цепочки токенов.

_Ассистенты_, и, в частности, _Copilot'ы_ (code assistant) --- это основанные на LLM инструменты, предназначенные для предоставления подсказок, автодополнения текста или кода "на лету". Они могут использовать и _Reasoning_, и _Non-Reasoning_ модели. Функционал _Ассистентов_ основан на использовании специального [_системного запроса_](#отступление-об-особенностях-запросов-для-локальных-llm), и оптимизации под скорость работы, чтобы исключить большие задержки при работе с пользователем. Архитектурно это не отдельный класс моделей, а форма практического применения моделей.

Для полноты обзора: модели для визуального распознавания текста, OCR --- это _VL_, _Vision_, _Multimodal_; _Embedding_ модели превращают текст в вектор эмбеддингов (см. [алгоритм работы LLM](#алгоритм-работы-нейросети-трансформера)).

**_Резюмируя:_**

* модели _base_ нужны _только_ для исследователей и создателей LLM для дальнейшего дообучения для каких-то частных конкретных задач;

* _Instruct_ модели умеют вести диалог, все онлайн-сервисы --- это instruct модели;

* _Instruct_ модели делятся на _Reasoning_, и _Non-Reasoning_. Первые лучше отвечают, но намного медленнее вторых;

* _Coder_ модели для программирования, могут писать код или документацию к коду по запросу; могут применяться в составе сред разработки, в том числе как _Copilot_;

* _Math_ модели вряд ли понадобятся;

* _Vision_ (_VL_) вместе с _Embedding_ используются как вспомогательные модели для OCR загружаемых документов;

* _Multimodal_ модели --- это универсальные модели со встроенным OCR, бывают и _Reasoning_, и _Non-Reasoning_;

* _Ассистенты_, и, в частности, _Copilot'ы_ --- это форма практического применения моделей, а не отдельный класс моделей.


## Технологии *RL* и *MoE*

Прогресс в области LLM технологий происходит невероятными темпами, ещё год назад было невозможно себе представить, что на персональном компьютере можно запустить хоть что-то дающее хоть какой-то результат. Полгода назад запускаемые локально модели требовали слишком больших ресурсов для нормальных результатов. А уже сегодня на ноутбуке можно запускать модели, которые дают вполне нормальные результаты. Этого добились комбинацией двух подходов в обучении LLM: *RL* и *MoE*.

Новейшие _Instruct_ модели (2025) дообучаются методом *Reinforcement Learning* (*RL*) --- [Обучение с подкреплением](https://ru.wikipedia.org/wiki/Обучение_с_подкреплением), в отличии от предыдущего поколения LLM, которые обучались методом *Reinforcement Learning from Human Feedback* (RLHF) --- [Обучение с подкреплением на основе отзывов](https://ru.wikipedia.org/wiki/Обучение_с_подкреплением_на_основе_отзывов_людей). В методе *RL*, при обучении, помимо заранее заданных массивов вопрос-ответ, или массивов логических цепочек, модель сама в процессе обучения создаёт новые пары вопрос-ответ, новые логические цепочки, и проверяет их на корректность, либо самостоятельно, либо с помощью другой языковой модели; результаты этой проверки становятся ключом для метода подкрепления и дальнейшего закрепления требуемого поведения. Этот метод обучения приводит к некой _Самоинтроспекции_ (_Self-Reasoning_) моделей, в результате чего внутренние данные моделей становятся лучше взаимосвязаны, кластеризованы, лучше ассоциированы; такие модели меньше ошибаются, лучше улавливают контекст запросов. Обученные методом *RL* модели могут быть как _Reasoning_, так и _Non-Reasoning_.


Другой подход обучения LLM позволяет создавать модели [*"Mixture of Experts"*](https://en.wikipedia.org/wiki/Mixture_of_experts) (*MoE*), или *"модели экспертов"* (*"комбинация экспертов"*), в которых, при выполнении, в каждый момент времени задействуется только небольшая часть (типично 5--10&nbsp;%) весов, непосредственно ответственная за выполнение запросов текущего типа. Такое поведение обеспечено кластеризацией весов со схожими аспектами задач, областями ответственности. *MoE* модели можно представить как набор небольших специализированных моделей в общей упаковке, с маршрутизатором отправляющим данные тому или иному "эксперту" в зависимости от содержимого данных. Модели *MoE* имеют преимущество перед обычными "плотными" моделями в том, что требуют на порядок меньшего количества вычислительных затрат на выполнение при равных размерах. Из недостатков следует отметить, что общая точность несколько падает по сравнению с "плотными" моделями того же размера.


Комбинация методов *обучения с подкреплением* (*RL*) и *моделей экспертов* (*MoE*) позволяет создавать модели, обладающие высокой скоростью работы и точностью, а также обеспечивающие заданные стратегии поведения системы. В качестве примера подобных современных моделей можно привести открытые *MoE* модели семейства [*Qwen3*](https://huggingface.co/Qwen).


## Размеры и квантизация моделей

В качестве одной из базовых характеристик языковых моделей можно отметить их размер --- пишется как 3B, 70B и т.п., обозначает количество коэффициентов-весов в модели в B-billions --- в миллиардах. Например, у не квантизированной (см. далее) 3B модели с размером весов *FP16* (2&nbsp;байта), размер всей модели будет 3E9&nbsp;*&nbsp;2&nbsp;байт&nbsp;=&nbsp;6&nbsp;Гбайт.

Модели бывают исходные, где все веса имеют размер использовавшийся при обучении модели, *FP16* или даже *FP32.* И бывают квантизированные модели, веса у которых были округлены до меньшего количества занимаемых бит для экономии занимаемой памяти и ускорения работы. Уровней квантизации-округления [много](https://gist.github.com/Artefact2/b5f810600771265fc1e39442288e8ec9) [разных](https://huggingface.co/mradermacher/grok-1-GGUF), от 1&nbsp;байта на коэффициент (*Q8_0*), до 1-2&nbsp;битов на коэффициент (*Q2_K* и т.п.). Квантизированные модели всегда менее точные, чем исходные, поэтому, при возможности, следует использовать неквантизированные исходные *FP16* модели. Характерная зависимость точности (perplexity) моделей от степени квантизации представлена на графике [Perplexity vs. Quantization](https://github.com/ggerganov/llama.cpp/pull/1684). Из графика следует, что *Q8_0* практически неотличима от *FP16*; но чем больше модель ~~огрублена~~ округлена, тем хуже её качество. Также из графика следует, что даже самая сжатая модель большего размера будет лучше, чем не квантизированная модель меньшего размера.

Разные коэффициенты/веса моделей имеют разное влияние на конечный результат работы моделей, и есть некоторое [количество](https://arxiv.org/abs/2402.17762) [весов](https://arxiv.org/abs/2411.07191) (логическое ядро?), которые в наибольшей степени определяют точность ответа, и, даже небольшое округление этих весов приводит к сильной деградации работы модели. Алгоритм квантизации должен уметь находить такие ключевые веса и ограждать их от излишнего округления. Поэтому, модель, квантизированная до одного и того же уровня плотности, но разными подходами и алгоритмами квантизации, может иметь принципиальное разное качество.

Процесс квантизации моделей является достаточно сложной процедурой, которая сама по себе требует в какой-то мере "обучения" алгоритма под каждую квантизируемую модель. Такие подходы "умной" квантизации начинают развиваться, и, в качестве примера можно привести проект [*Unsloth Dynamic 2.0 Quants*](https://huggingface.co/collections/unsloth/unsloth-dynamic-20-quants-68060d147e9b9231112823e6), в рамках которого проведена такая "умная" динамическая квантизация множества самых популярных открытых языковых моделей. (На сайте по приведённой ссылке в каталоге представленных моделей, файлы LLM с динамической квантизацией обозначаются суффиксом *-UD-*). Подобная динамическая квантизация позволяет практически без потери качества модели значительно уменьшить её размер и время выполнения.


При выборе степени квантизации/сжатия модели для локального использования важное значение имеет область применения LLM: при написании программ или формул, т.е. там, где принципиальное значение имеет каждый символ и любые ошибки недопустимы, даже незначительная квантизация *Q8_0* может вносить существенные ошибки. Для практического применения всегда стоит опробовать и сравнивать модели в применении к конкретной задаче: и *FP16* модель меньшего размера, и модели *Q8_0*, *Q4_K_M* большего размера.

На практике, применение локальных LLM сильно ограничено их фактическим размером, в первую очередь это ограничение связано со скоростью шины памяти --- такой большой массив данных как модель, просто физически долго прокачивать из памяти в процессор.

Для "плотных" моделей, как показывает опыт применения LLM, при отсутствии GPU, для современного процессора следует выбирать модель размером до 6&nbsp;Гбайт (оптимально до 3&nbsp;Гбайт), иначе будет работать совсем уж медленно. При наличии GPU, если размер модели помещается в VRAM, то работа модели будет в разы быстрее, что связано с, в разы более широкой шиной памяти VRAM. Если же модель полностью не помещается в VRAM, то та часть модели, что не поместилась в VRAM, будет обрабатываться процессором и будет иметь вышеизложенные соответствующие ограничения на размер.

Для *MoE* моделей ограничения по размеру на порядок слабее, и тут на первый план выходит скорее ограничение общего количества оперативной памяти --- какая модель поместилась в оперативную память, с той и следует работать.


## Специализация моделей

Современные, сильные универсальные модели имеют размер более сотни миллиардов весов (100B), что делает невозможным их локальный запуск. Небольшие модели, доступные по размеру для локального запуска, имеют те или иные сильные и слабые стороны; и выбор подходящей специализированной модели порой имеет большее влияние на успешность решения задачи, чем выбор модели большего размера.

_Note:_ Этот список мало того что неполный, так ещё постоянно устаревает; и, скорее всего, на данный момент уже не актуален.

* Современные (2025) [*MoE* модели](https://llm.extractum.io/list/?moe=), например [Qwen3-30B-A3B](https://qwenlm.github.io/blog/qwen3/), очень хорошо справляются с большинством типов задач; но не очень быстрые.

* Для математики, формул, программирования, работы с Markdown, хорошо работают модели для программирования, например [Qwen2.5 Сoder](https://ollama.com/library/qwen2.5-coder).

* Для математики и формул лучше всего работают _Reasoning_ модели.

* Со сложными задачами могут справиться _только_ _Reasoning_ модели, например [Qwen3-30B-A3B](https://ollama.com/library/qwen3), [QwQ-32B](https://ollama.com/library/qwq) или [DeepSeek R1](https://ollama.com/library/deepseek-r1).

* Для перевода текстов может применяться любая модель, которая понимает русский язык; но, есть специализированная модель [Aya Expance](https://ollama.com/library/aya-expanse), заточенная именно для *переводов на всевозможные языки*.

* Для ответов на простые вопросы не стоит привлекать _Reasoning_ модели --- времени потратится много, объём ответа вырастет, а точность будет не особо лучше.


### Особенности работы *MoE* моделей на примере *Qwen3* {.unnumbered}

Весной 2025 вышел набор универсальных моделей [*Qwen3*](https://qwenlm.github.io/blog/qwen3/), все из которых одновременно являются и _Reasoning_, и _Non-Reasoning_. Также, среди набора моделей *Qwen3*, пара моделей являются *"Mixture of Experts"* (*MoE*) моделями, и меньшая из них (*Qwen3-30B-A3B*) отлично работает на персоналке/ноутбуке без выделенного видеоадаптера. В этом параграфе речь пойдёт именно об этой *MoE* модели *Qwen3-30B-A3B*, причём в [варианте динамической квантизации от Unsloth](https://huggingface.co/collections/unsloth/unsloth-dynamic-20-quants-68060d147e9b9231112823e6).

Модели *"Mixture of Experts"* (*MoE*) в каждый конкретный момент работы задействуют только небольшую часть весов, например модель [*Qwen3-30B-A3B*](https://huggingface.co/unsloth/Qwen3-30B-A3B-GGUF) задействует только 3B из 30B весов; что ведёт к ускорению работы _на порядок_, по сравнению с обычными, "плотными" моделями. Но, общая точность несколько падает, и соответствует, примерно, _в два раза_ меньшим, по размеру, "плотными" моделями. Конкретный пример: квантизированная модель [*Qwen3-30B-A3B-GGUF:Q4_K_XL*](https://huggingface.co/unsloth/Qwen3-30B-A3B-GGUF)^[занимает 18&nbsp;ГБ] на типичном процессоре выполняется в пять с лишним раз быстрее, чем плотная модель той же точности [*Qwen3-14B-GGUF:Q4_K_XL*](https://huggingface.co/unsloth/Qwen3-14B-GGUF)^[занимает 9&nbsp;ГБ], и обеспечивает 10-15 токенов в секунду, или страницу текста в минуту (ср. со страницей в 5 минут).

Ещё одной особенностью *MoE* моделей является то, что квантизация не сильно ускоряет выполнение по сравнению с исходными моделями, т.е. время выполнения моделей не сильно зависит от степени квантизации. Одна из самых сильных квантизаций *Q2_K* выполняется всего-лишь в два раза быстрее исходной *FP16* модели (не смотря на то, что по объёму в 8 раз меньше), а квантизация *Q8_0* по скорости выполнения отличается от *FP16* максимум на 20--30&nbsp;%. Поэтому, для *MoE* моделей, следует выбирать самую лёгкую степень квантизации, которую удастся загрузить в память компьютера. В частности, для модели _Qwen3-30B-A3B_, в зависимости от объёма оперативной памяти, выбор следующий:

* если памяти 16&nbsp;ГБ, то можно попробовать запустить модель в квантизации [*Q2_K_XL*](https://huggingface.co/unsloth/Qwen3-30B-A3B-GGUF)^[занимает 12&nbsp;ГБ]. (_Note:_ 16&nbsp;ГБ для *MoE* LLM модели занимающей 12&nbsp;ГБ, это совсем впритык, но возможно. Выполнение, скорее всего, будет несколько подтормаживать, не обеспечивая доступную для процессора скорость в 10 токенов в секунду);

* если памяти 32&nbsp;ГБ и более, то хорошо подойдёт квантизация [*Q4_K_XL*](https://huggingface.co/unsloth/Qwen3-30B-A3B-GGUF)^[занимает 18&nbsp;ГБ]. По вычислительным затратам на выполнение, эта квантизация, отличается менее чем на 30&nbsp;% от меньшей *Q2_K_XL*;

* если памяти 64&nbsp;ГБ, то можно попробовать *Q8_K_XL*^[занимает 36&nbsp;ГБ], которая будет выполняться в полтора раза медленнее, чем *Q2_K_XL*, при, практически, идеальной точности, очень близкой по качеству к официальной онлайн модели _Qwen3-30B-A3B_ на сайте <https://chat.qwen.ai/>.

При использовании программы *ollama* (см. [далее](#open-webui-with-ollama)) для загрузки LLM выполнить^[занимает 12&nbsp;ГБ]:

```cmd
ollama pull hf.co/unsloth/Qwen3-30B-A3B-GGUF:Q2_K_XL
```

Режим работы _Reasoning / Non-Reasoning_ выбирается добавлением в конец запроса ключа `/no_think` для режима без размышлений. В качестве примера показано выполнение запроса к LLM из командной строки с ключом для отключения режима размышлений:

```cmd
ollama run hf.co/unsloth/Qwen3-30B-A3B-GGUF:Q2_K_XL "Посчитай сумму цифр в числе 2 в 70 степени? /no_think" --verbose
```


## Программы для работы с локальными LLM

В этой главе рассмотрены несколько программ для применения LLM, из тех что попроще.


### LLM провайдеры {.unnumbered}

Существует небольшое число инструментов, непосредственно выполняющих LLM: [llama.cpp](https://github.com/ggerganov/llama.cpp), [vLLM](https://github.com/vllm-project/vllm), [transformers](https://github.com/huggingface/transformers), плюс какие-то графические --- это LLM провайдеры. Есть менеджеры библиотек LLM моделей: [Ollama](https://github.com/ollama/ollama), [huggingface_hub](https://github.com/huggingface/huggingface_hub). И, есть большое количество [программ](https://github.com/vince-lam/awesome-local-llms#open-source-local-llm-projects) для запуска LLM --- это  интерфейсы, графические "оболочки", которые запускают тот или иной LLM провайдер, и используют менеджеры библиотек LLM.

*Safetensors*, это исходный формат, в котором обучаются модели; он не поддерживает квантование. Работать непосредственно с форматом *Safetensors* умеют только *PyTorch*, *HuggingFace Transformers* и *vLLM*. Остальные библиотеки и провайдеры конвертируют файлы моделей в другие форматы, более совместимые для применения на GPU, а также позволяющие провести квантование моделей.


| Название                 | CPU | GPU | Формат LLM                         | Замечания       |
|:-------------------------|:---:|:---:|:-----------------------------------|:----------------|
| PyTorch                  | Да  | Да  | Safetensors                        | Базовая Python библиотека, написана на C++ |
| HuggingFace Transformers | Да  | Да  | Safetensors                        | Использует PyTorch |
| vLLM                     | Нет | Да  | Safetensors, GPTQ, AWQ             | Написана на Python/C++, не использует сторонние библиотеки |
| llama.cpp                | Да  | Да  | GGUF, может импортировать GPTQ/AWQ | Написана на C/C++, не использует сторонние библиотеки |
| Ollama                   | Да  | Да  | Свой формат, загружает через GGUF  | Написана на основе llama.cpp |
: LLM провайдеры {tbl-colwidths="[10,5,5,30]"}

### Параметры и шаблоны {.unnumbered}

При передаче запроса модели на выполнение, используются [_шаблоны_](https://huggingface.co/docs/transformers/main/en/chat_templating), которые преобразуют запрос в специально промаркированный текст, на формате которых обучались модели --- у каждой модели обычно свой шаблон, и отступление от конкретного формата запроса сильно влияет на качество ответа. Помимо применения обычных шаблонов при запросе, существуют шаблоны шаблонов ([jinja](https://huggingface.co/docs/transformers/v4.34.0/en/chat_templating#how-do-chat-templates-work)) с широкими возможностями форматирования запроса в целевой формат шаблона (применяется в LM Studio).

Также стоит учитывать, что моделям в зависимости от режима работы (с размышлениями или без) требуется задавать разные наборы параметров LLM, таких как Temperature, TopP, TopK, MinP и т.д.

Поэтому, один и тот же запрос к одной и той же модели в разных программах, или даже просто в разных режимах, может выдавать очень разные по качеству ответы, в зависимости от применяемых параметров, шаблонов и шаблонов шаблонов.


### Спекулятивное декодирование {.unnumbered}

*Спекулятивное декодирование* (*Speculative Decoding*), это подход, при котором вначале лёгкой моделью создаётся "черновик" цепочки токенов, после чего основная модель на основе черновой цепочки генерирует ответ. Этот подход позволяет в два-три раза ускорить генерацию ответа.


### LM Studio

<https://lmstudio.ai/>

Удобная программа "По одной кнопке". Удобный встроенный поиск моделей, возможность настройки параметров модели при запуске, умеет использовать _спекулятивное декодирование_. Умеет загружать pdf/txt прямо при запросе. Но есть два больших минуса: не opensorce --- _проприетарная_, и, _лицензия запрещает любое коммерческое применение результатов!_ А так да, для "поиграться", самое то.

Установить:
```cmd
winget install --id=ElementLabs.LMStudio -e
```

#### Использование: {.unnumbered .unlisted}

* для увеличения или уменьшения шрифта в интерфейсе использовать _\<Ctrl+\>_ и _\<Ctrl-\>_ (основан на _Electron_);

* для контроля над LLM необходимо включить режим "Power User" в самом низу, если ещё не включен;

* выбрать и скачать LLM модель: слева иконка лупы;

* управление параметрами запуска скачанных моделей (здесь же удаление): слева иконка открытой папочки;

* выбрать модель из уже скачанных для загрузки, или сменить загруженную модель на другую: сверху плашка с названием модели, при нажатии выпадет список доступных для загрузки;

* начать чат с моделью: слева в самом верху иконка сообщения;

* работа с документами: "скрепкой" подцепить файл и запрос будет работать с данными из файла.

_Note:_ LMStudio (на 2024) использует [устаревшую нотацию](#отступление-про-задание-и-отображение-математических-выражений) для отображения формул, поэтому, в LMStudio при запросах связанных с математикой, необходимо явно указывать использовать устаревшие символы, добавляя к запросу фразу: _(Use dollar and double dollar signs for math in answer)_.

_Note:_ Существует [_opensource_](https://github.com/janhq/jan) аналог LMStudio --- [**Jan**](https://jan.ai/), но, конечно, пока с не столь широким функционалом. Установить можно через [_Winget_](https://winstall.app/apps/Jan.Jan).

### Open WebUI (with Ollama)

<https://openwebui.com/>\
Достаточно большие возможности при несложной установке и простом интерфейсе. Умеет отображать Markdown и LaTeX формулы.

Установить [Ollama](https://ollama.com/):
```cmd
winget install --id=Ollama.Ollama -e
```

[Установка](https://github.com/open-webui/open-webui#installation-with-default-configuration)^[размер скачиваемого образа 4.0ГБ, займёт 8.5ГБ] и запуск Open WebUI с использованием уже установленного Ollama:
```cmd
docker run -d -p 3000:8080 --gpus all ^
       --add-host=host.docker.internal:host-gateway ^
       -v open-webui:/app/backend/data --name open-webui ^
       --restart always ghcr.io/open-webui/open-webui:cuda
```
Open WebUI при этом запустится как фоновый процесс (все его свойства/характеристики можно посмотреть в интерфейсе _Docker Desktop_). По адресу [http://localhost:3000](http://localhost:3000) появится приложение в виде веб-страницы.

В случае ошибки соединения _Open WebUI: Server Connection Error_ есть [другие варианты установки](https://github.com/open-webui/open-webui?tab=readme-ov-file#open-webui-server-connection-error).

После установки вышеприведённую команду больше не потребуется запускать. Open WebUI можно запустить либо через графический интерфейс DockerDesktop, либо из командной строки:
```cmd
docker start open-webui
```

Завершить Open WebUI: `docker stop open-webui`

Для скачивания моделей следует применять команды, скопированные со страницы <https://ollama.com/library> для выбранной [LLM модели](https://ollama.com/library/qwen2.5-coder:1.5b-instruct-fp16), где команду `run` заменить на `pull`, например:
```cmd
ollama pull qwen2.5-coder:1.5b-instruct-fp16
```
(Вроде бы есть экспериментальная возможность загрузки моделей прямо изнутри Open WebUI, но это надо где-то включать)

При необходимости обновления Ollama до новой версии выполнить команду:
```cmd
winget upgrade ollama
```

При необходимости обновления Open WebUI до новой версии выполнить команду:
```cmd
docker run --rm --volume /var/run/docker.sock:/var/run/docker.sock ^
       containrrr/watchtower --run-once open-webui
```

#### Использование: {.unnumbered .unlisted}

При первом запуске программа попросит задать имя, имейл и пароль, это чтобы никто другой не воспользовался данными пользователя --- они хранятся в зашифрованном виде, а имейл и пароль никуда не передаются. Если забыть пароль, то данные будут потеряны.

* Выбрать модель из загруженных: сверху слева кнопка _Arena Model_.

* Новый чат/список чатов: слева сверху три горизонтальные полоски.

_Note:_ В Open WebUI по умолчанию стоит включенной настройка _Rich Text Input for Chat_, которая пытается на лету превращать набираемый текст с разметкой Markdown в отформатированный текст, что приводит к излишней "оптимизации" и [потере некоторых символов вроде перевода строк](https://github.com/open-webui/open-webui/issues/9759#issuecomment-2677880302) и т.п. Эту опцию следует отключить в *Settings > Interface > Chat > Rich Text Input for Chat*.


### Page Assist (with Ollama)

[**Page Assist**](https://github.com/n4ze3m/page-assist) --- это [плагин](https://chromewebstore.google.com/detail/page-assist-a-web-ui-for/jfgfiigpkhlkbnfnbobbkinehhfdhndo) для Chromium. Этот плагин умеет в разметку Markdown, рисовать LaTeX формулы, и подсвечивать программный код. Удобный инструмент, но на текущей версии (v1.3.4) начинает сильно тормозить, если поднакопятся чат-сессии или данные ([bug](https://github.com/n4ze3m/page-assist/issues/303)).

Установить [Ollama](https://ollama.com/) (если ещё не установлен):
```cmd
winget install --id=Ollama.Ollama -e
```

Установить плагин для Chromium [Page Assist - A Web UI for Local AI Models](https://chromewebstore.google.com/detail/page-assist-a-web-ui-for/jfgfiigpkhlkbnfnbobbkinehhfdhndo).

На странице <https://ollama.com/models> выбрать модель (например [qwen2.5-coder:1.5b](https://ollama.com/library/qwen2.5-coder:1.5b-instruct-fp16) или [3b](https://ollama.com/library/qwen2.5-coder:3b-instruct-fp16)), скачать (с момента установки плагина появится кнопочка-стрелочка _Скачать_ рядом с моделью), и запустить в Page Assist.

### vLLM

*\<TBD\>*

<https://github.com/vllm-project/vllm>\
LLM провайдер, поддерживающий большое количество форматов моделей, мультимодальные модели. Его главное преимущество --- он может запускать исходные модели в формате _SafeTensors_, без преобразования в упрощённые форматы типа GGUF, без каких-либо изменений.

Может использоваться приложениями в той же роли что и Ollama.

#### Установка и запуск, вариант попроще {.unnumbered .unlisted}

Установка:
```cmd
pipx install vllm huggingface_hub[cli]
```

Скачивание модели с <https://huggingface.co/> и запуск сервиса с _OpenAI API_ доступного по адресу <http://localhost:8088>
```cmd
vllm serve Qwen/Qwen2.5-Coder-3B-Instruct --port 8088
```

Здесь `8088` --- номер порта, на котором будет работать сервис.

#### Установка и запуск {.unnumbered .unlisted}

```cmd
docker run --name vllm--Qwen--Qwen2.5-Coder-3B-Instruct --runtime nvidia --gpus all ^
    -v ~/.cache/huggingface:/root/.cache/huggingface -p 8088:8000 ^
    --ipc=host vllm/vllm-openai:latest --model Qwen/Qwen2.5-Coder-3B-Instruct
```

И запуск в дальнейшем
```cmd
docker start vllm--Qwen--Qwen2.5-Coder-3B-Instruct
```
```cmd
docker stop vllm--Qwen--Qwen2.5-Coder-3B-Instruct
```

Старт контейнера не мгновенный, зависит от размера модели --- пока модель загрузится с диска в память и/или видеопамять.

API сервиса будет по адресу <http://localhost:8088>.

Запуск через docker предполагает свой контейнер на каждую LLM модель. Конечно, быстро модельки так не по-перебираешь, но _vLLM_ на такое и не рассчитан, _vLLM_, это, скорее, про постоянно работающий сервис.


_Note:_ Удалить docker контейнер: `docker container rm vllm--Qwen--Qwen2.5-Coder-3B-Instruct`. Переименовать docker контейнер: `docker container rename vllm--Qwen--Qwen2.5-Coder-3B-Instruct new-name`.



## ИИ помощники

### _Roo Code_

<https://roocode.com/> <https://github.com/RooCodeInc/Roo-Code>, форк _cline_.

### _Continue_

<https://www.continue.dev/> <https://github.com/continuedev/continue>

*\<TBD\>*

[Внедряем AI Code Assistant в разработку бесплатно и без вендорлока --- Инструкция](https://habr.com/ru/articles/875816/):

https://ollama.com/blog/continue-code-assistant

https://vsegpt.ru/ExtTools/Continue

## Работа с документами

Для работы со своими документами/файлами применяется технология [RAG](https://en.wikipedia.org/wiki/Retrieval-augmented_generation) --- Retrieval-Augmented Generation. Продвинутые пользователи могут использовать более мощные [инструменты](https://github.com/vince-lam/awesome-local-llms#open-source-local-llm-projects), например [SillyTavern](https://github.com/SillyTavern/SillyTavern), а здесь далее будут описаны способы попроще.

### LMStudio

В этом  приложении нет какого-то особого _RAG_ или _Баз Знаний (Knowledge Base)_, всё намного проще --- прикрепляются файлы "скрепкой", и запускается запрос. Вполне неплохо справляется.

### Open WebUI

В Open WebUI можно создать _Базу Знаний (Knowledge Base)_ на основе локальных текстов, [инструкция](https://docs.openwebui.com/tutorials/tips/rag-tutorial/):

* Загрузить данные: _Workspace > Knowledge > + Create a Knowledge Base_ и загрузить файлы.

* Создать Модель с загруженными данными: _Workspace > Models > + Add New Model_, выбрать исходную LLM модель, выбрать данные _Knowledge Source_, сохранить новую Модель-с-Данными (это может быть долго).

* Выбрать созданную Модель-с-Данными для нового чата.

### Page Assist

В Page Assist для создания _Базы Знаний_ на основе локальных текстов потребуется скачать _embedding_ модель [nomic](https://ollama.com/library/nomic-embed-text), которая будет читать загруженные текстовые документы и транслировать их в [векторное семантическое пространство](https://www.mongodb.com/developer/products/atlas/choose-embedding-model-rag/) [невысокой размерности](https://huggingface.co/spaces/mteb/leaderboard). В настройках _Settings > RAG Settings_ выставить _nomic-embed-text_ в качестве _Embedding Model_.

* В меню _Settings > Manage Knowledge > Add New Knowledge_ загрузить нужные pdf/doc/txt, и дождаться их обработки.

* На главной странице, нажав снизу на _"квадратики"_ выбрать нужную базу знаний. После чего запросы к LLM будут производиться с учётом данных из файлов.

### Примечание по RAG технологии {.unnumbered .unlisted}

Следует помнить, что на 2024г технология новая, отработана слабо, поэтому стоит учитывать, что, к примеру, данные могут выгрузиться в базу данных не полностью, или с ошибками, это особенно часто случается при работе с pdf, где разметка страницы может прерывать текст, а формулы без OCR вообще не вытащить. Существуют модели (и использующие их программы), которые могут не только выдёргивать тексты из pdf, но и умеют OCR pdf, картинок и видео, например [Qwen2-VL](https://huggingface.co/Qwen/Qwen2-VL-7B-Instruct). Но для их применения необходимы другие, более сложные программы, например [vLLM](https://github.com/vllm-project/vllm), [SillyTavern](https://github.com/SillyTavern/SillyTavern) или [quivr](https://github.com/QuivrHQ/quivr).


### Примечание по LLM chain технологии {.unnumbered .unlisted}

Создать одну универсальную модель гораздо сложнее, чем создать несколько небольших специализированных моделей заточенных на конкретную задачу. По технологии цепочки моделей, данные, полученные на выходе из одной модели, передаются на вход другой модели, [формируя](https://flowiseai.com/) [конвейер](https://github.com/langchain-ai/langchain) [обработки](https://haystack.deepset.ai/) [данных](https://github.com/danielmiessler/fabric).


## Алгоритм работы нейросети-трансформера

Ссылки:

* [wiki: Большая языковая модель](https://ru.wikipedia.org/wiki/Большая_языковая_модель)
* [wiki: Transformer](https://en.wikipedia.org/wiki/Transformer_(deep_learning_architecture))
* [Трансформер](https://neerc.ifmo.ru/wiki/index.php?title=Трансформер)
* [Объясняем простым языком, что такое трансформеры](https://habr.com/ru/companies/mws/articles/770202/)
* [Transformer в картинках](https://habr.com/ru/articles/486358/)

### Алгоритм трансформера {.unnumbered .unlisted}

Несколько упрощённое описание алгоритм работы нейросети типа трансформер применяемой в LLM.

1. Входной текст разбивается на токены с помощью [токенизатора](https://huggingface.co/learn/llm-course/ru/chapter2/4), основанного на заранее обученном словаре (обычно 10–50 тыс. элементов). Этот шаг не является частью (слоем) нейросети, а является предварительной обработкой текста.

2. С помощью входного эмбеддинг-слоя нейросети каждый токен преобразуется в числовой^[floating point, FP16] вектор ([эмбеддинг/embedding](https://en.wikipedia.org/wiki/Word_embedding)) фиксированной длины (например, 512), являющийся точкой в [многомерном семантическом пространстве](https://en.wikipedia.org/wiki/Semantic_space). Также к этим векторам-эмбеддингам добавляется [_позиционное кодирование_](https://en.wikipedia.org/wiki/Transformer_(deep_learning_architecture)#Positional_encoding), чтобы модель могла учитывать порядок слов. Над этим набором эмбеддингов проводится вся дальнейшая работа трансформера, причём, т.к. _позиционное кодирование_ уже встроено в сами эмбеддинги, то порядок обработки эмбеддингов не важен, что позволяет эффективно распараллеливать обработку.

3. Алгоритм ["механизм внимания"](https://arxiv.org/abs/1706.03762) (self-attention) вычисляет, какие части входной последовательности наиболее важны для понимания каждой конкретной её позиции, т.е. устанавливает смысловые связи между всеми (каждый с каждым) точками семантического пространства (эмбеддингами). Для этого для каждого эмбеддинга создаются три вектора: Query (Q), Key (K) и Value (V), по которым вычисляется матрица внимания: *Attention(Q, K, V) = softmax(QK^T / sqrt(d_k)) \* V* ^[*d_k = length(Q) = length(K)*], которая, собственно, и описывает связи между ембеддингами и показывает, какие части входа наиболее важны при обработке конкретного токена. Полученная матрица внимания *Attention(Q,K,V)* описывает _представление_ каждого эмбеддинга, учитывающее его контекст.

4. Полученные представления *Attention(Q,K,V)* проходят через [Feed-Forward Network](https://en.wikipedia.org/wiki/Transformer_(deep_learning_architecture)#Feedforward_network) (FFN), которая применяется независимо к каждому эмбеддингу (т.е. возможна параллельная обработка). После этого формируется новый набор эмбеддингов, уже с более глубоким семантическим смыслом; при этом количество эмбеддингов не изменяется.

5. Этот процесс повторяется несколько раз: последовательность эмбеддингов проходит через множество уровней ("слоёв"), состоящих из пары: self-attention (п.3) + FFN (п.4). Обычно таких уровней от 12 до 48. На каждом уровне модель углубляет понимание контекста и взаимосвязей между элементами последовательности.

6. На выходе из сети получается последовательность эмбеддингов. Для предсказания следующего токена ответа используется специальный выходной эмбеддинг, вычисляемый в зависимости от заданного алгоритма: последний в последовательности эмбеддинг; вычисленный методом beam search; или др. методы.

7. Для сопоставления выходному эмбеддингу конкретного токена, этот выходной эмбеддинг проходит через дополнительный выходной _линейный слой_ НС, который преобразует его в вектор^[называется logits] размером со словарь токенов (см. п.1), а затем через функцию softmax --- в вероятностное распределение для каждого токена из словаря. Следующий токен ответа выбирается согласно этому распределению вероятностей в зависимости от заданного алгоритма: жадный (greedy, temperature=0) --- самый вероятный; случайный выбор среди наиболее вероятных с учётом температуры (шума); top-k sampling, или nucleus sampling (top-p) и др.

8. Выбранный токен ответа добавляется в конец к исходной последовательности, и весь процесс повторяется заново, начиная с п.2, пока не будет достигнут конец ответа (получен токен `<EOS>`), или превышена максимальная длина генерации.

### Структура трансформера {.unnumbered .unlisted}

Несколько приближённо, но можно сказать, что каждый слой НС представляет собой матрицу, и прохождение информации через слой является операцией умножения этой матрицы на каждый ембеддинг из набора, представляющего запрос плюс текущую часть ответа. Ниже ориентировочные размеры матриц для ключевых слоёв в типичной Transformer-модели, информация от языковой модели Qwen:


1. Embedding Layer
    - Вход: индекс слова (или токена)
    - Выход: векторное представление токена
    - Матрица весов: `(vocab_size × d_model)`
      - `vocab_size`: ~30,000–100,000 (размер словаря)
      - `d_model`: ~512–8192 (размерность скрытого состояния)
    - *Пример: Для GPT-2 small (`d_model=768`, `vocab_size=50257`) --- матрица будет иметь размер ~`50k × 768`*

2. Self-Attention (Q, K, V проекции). Каждый из трёх проекторов (Query, Key, Value):
    - Матрицы: `(d_model × d_k)` или `(d_model × d_v)`
    - Обычно `d_k = d_v = d_model // num_heads`
    - *Пример: GPT-2 small имеет `d_model=768`, `num_heads=12` => `d_k = d_v = 64` <br> Тогда каждая матрица Q/K/V: `768 × 64` <br> Иногда эти три матрицы объединяются в одну: `d_model × (3*d_k)`*

3. Проекция после Self-Attention (Dense). После конкатенации голов внимания:
    - Матрица: `(d_model × d_model)`

4. Feed-Forward Network (FFN). Обычно состоит из двух линейных слоёв:
    - Первый: `(d_model × d_ff)`
    - Второй: `(d_ff × d_model)`
      - `d_ff`: обычно в 2–8 раз больше `d_model` (например, 2048–30720)
    - *Пример: Для GPT-2 small `d_model=768`, `d_ff=3072` <br> =>  Матрицы: `768×3072` и `3072×768`*

5. Output (Head / LM Head)
    - Проекция на логиты: `(d_model × vocab_size)`
    - Может быть тем же весом, что и embedding (weight tying)



| Модель | d_model | num_heads | d_ff | Embedding / <br> Output | Q/K/V (на head) | FFN      |
|--------|---------|-----------|------|--------------------|-----------------|----------|
| GPT-2 small  |   768  | 12  |  3072 | 50k × 768         | 768 × 64        | 768×3072 |
| GPT-2 medium |   1024 | 16  |  4096 | 50k × 1024        | 1024 × 64       | 1024×4096 |
| LLaMA 7B     |   4096 | 32  | 11008 | 32k × 4096        | 4096 × 128      | 4096×11008 |
| GPT-3 (175B) |  12288 | 96  | 49152 |  12k × 12k        |  12k × 128      |  12k × 49k |

: Примеры приблизительных размеров матриц для популярных языковых моделей

_Note:_ Размеры матриц растут квадратично с увеличением `d_model`.






# _Приложение:_ Консольные терминалы и приложения

Глава для продвинутых пользователей. В этой главе установка и настройка следующего:

* консольный терминал Windows Terminal + Clink
* консольный терминал Conemu+Clink / Cmder
* Neovim
* управление Docker'ом
* Backup/Restore WSL систем

_Note:_ Далее в тексте будет применяться сокращение _WT_ --- _Windows Terminal_.

## Ограничения командной строки Windows

В Windows `*` (wildcard) [не](https://stackoverflow.com/questions/72434739/globbing-patterns-in-windows-command-prompt-powershell) [раскрывается](https://github.com/chrisant996/clink/discussions/548#discussioncomment-8137898) перед запуском программ, а передаётся прямо как звёздочка, и, скажем, обычная Linux команда `ls *` скажет, что нет такого файла `*`. У этого ограничения есть несколько решений:

* Использовать [BusyBox](https://frippery.org/busybox/), где в каждую [команду](https://www.busybox.net/downloads/BusyBox.html) встроен свой [глоббинг](https://frippery.org/busybox/globbing.html) и правильное распознавание `\` | `/` в путях, и, тот же `ls`, из состава BusyBox, сработает как в Linux. BusyBox, это альтернатива сборкам [Git-for-Windows](https://gitforwindows.org/)/[MSYS2](https://www.msys2.org/). Этот вариант подходит для использования с _WT_/_Conemu_.

* Использовать доработанный _Conemu_ --- [Cmder](https://cmder.app/), где глоббинг встроен в консольные скрипты, которые перед запуском команд осуществляют подмену _wildcards_ на аргументы, как в Linux shell.

* Другие варианты --- это использовать настоящий Linux shell, например, в виде терминала с WSL в WT/Conemu/Cmder, или, использовать bash/zsh из проектов [Git-for-Windows](https://gitforwindows.org/)/[MSYS2](https://www.msys2.org/) или [BusyBox](https://frippery.org/busybox/).

См. также пункт [Отступление об экранировани символов](#отступление-об-экранировани-символов).

### _Отступление_ о WT/Conemu vs. Cmder {.unnumbered .unlisted}

[**Cmder**](https://cmder.app/) --- это [донастроенный](https://conemu.github.io/en/cmder.html) [**Conemu**](https://conemu.github.io/en/), со встроенным набором стандартных [Linux утилит](https://gitforwindows.org/), плюс [Clink](https://mridgers.github.io/clink/). Т.е. Cmder всё необходимое ~~носит с собой~~ при установке скачивает заодно.  При запуске Cmder автоматически ищет установленные утилиты из _Git-for-Windows_ и прописывает их в пути (контролируется [опцией](https://github.com/cmderdev/cmder#command-line-arguments-for-initbat) _/nix_tools_). В случае с WT/Conemu эти утилиты изначально необходимо доустанавливать, и, возможно, прописывать вручную пути. Ещё у _Cmder_ есть некоторое преимущество --- это его мобильность ([portable](https://github.com/cmderdev/cmder/tree/master#single-user-portable-config)), т.е., что его можно носить и запускать преднастроенным с флешки. Из минусов Cmder --- настройки по умолчанию для интерфейса весьма сомнительные, их обязательно придётся править.

Но, Cmder, при стандартной установке с [Git-for-Windows](https://gitforwindows.org/), не умеет распознавать направление слешей: прямой и обратный, и, например, не сможет отработать такую команду:
```cmd
fd --hidden "\.vhdx$" %HOME% | xargs -I@ cp -v @ E:\backup\wsl\
```
Поэтому для нормальной работы Cmder потребуется доустанавливать BusyBox, и использовать опцию загрузки `/nix_tools 0`, чтобы по умолчанию не дописывались пути с [Git-for-Windows](https://gitforwindows.org/). Но в таком случае Cmder становится практически идентичен Conemu.

> В общем, Cmder --- это достаточно противоречивая утилита, подкупающая портативностью и преднастроенностью. Но, при должной настройке, Windows Terminal или Conemu будут даже лучше, чем Cmder, за исключением момента с портативностью.

В данном руководстве будут рассмотрены оба варианта настройки терминала: и _WT/Conemu+Clink+BusyBox_, и _Cmder_. Если Cmder уже установлен и настроен, то предлагается настроить [Windows Terminal на его использование](https://github.com/cmderdev/cmder/wiki/Seamless-Windows-Terminal-Integration). Если Cmder не установлен, то значит он вам не нужен и не надо с ним связываться. В этом случае предлагается установить и настроить Clink и BusyBox, чтобы получить универсальную командную оболочку, которая будет работать и в WT, и в Conemu. *В целом, Главы про настройку Conemu и Cmder приведены, в большей мере, по историческим причинам, чтобы не утерять данную информацию.*

## Консольная оболочка Clink и утилиты BusyBox

[**Clink**](https://mridgers.github.io/clink/) --- это дополнение оболочки (shell) для _Cmd.exe_, интегрирующее следующие [возможности](https://chrisant996.github.io/clink/clink.html#features): автодополнение, подсветка синтаксиса, история команд и поиск по ней, поиск файлов и папок, история переходов по папкам, алиасы.

[**BusyBox**](https://frippery.org/busybox/) --- это набор Linux [_команд_](https://www.busybox.net/downloads/BusyBox.html#commands), скомпилированных для Windows, которые поддерживают [wildcard](https://frippery.org/busybox/globbing.html) [globbing](https://stackoverflow.com/questions/72434739/globbing-patterns-in-windows-command-prompt-powershell), как в Linux. Будет использоваться для настройки _Windows Terminal_ (или _Conemu_).

_**Note**:_ _Clink_ не работает внутри _Far_, т.е, в терминале _Far_ по `<Ctrl+O>` все супер-пупер автодополнения и поиск от _Clink_ не сработают --- для работы _Clink_ должна использоваться отдельная консоль.

_Note:_ `ls` из состава BusyBox не работает с русскими буквами, решение описано чуть ниже.

### Установка Clink+BusyBox

Установить:
```cmd
scoop install busybox
scoop install clink
scoop install clink-completions
scoop install clink-flex-prompt
scoop install oh-my-posh
scoop bucket add nerd-fonts
scoop install nerd-fonts/IosevkaTerm-NF-Mono
```

_**Note**:_ `ls` из состава BusyBox не умеет показывать файлы с русскими буквами в имени файла. Поэтому, её следует заменить на утилиту `ls` из состава приложения `git`:
```cmd
scoop shim add ls %UserProfile%\scoop\apps\git\current\usr\bin\ls.exe
```
Пока не пофиксят этот [баг](https://github.com/rmyorston/busybox-w32/issues/17), данную процедуру придётся повторять после каждого обновления BusyBox, благо такие обновления могут быть проведены только вручную командой `scoop update --all`.


### Настройка Clink

[Настройка Clink](https://github.com/chrisant996/clink-fzf#how-to-install) для нечёткого (fuzzy) [поиска](https://github.com/chrisant996/clink-fzf#how-to-use), автоподстановки `~` и переменных окружения, интеграции с VSCode: скопировать соответствующие скрипты в отдельную постоянную папку и настроить Clink на их использование:
```cmd
mkdir %UserProfile%\.config\clink-scripts
cd %UserProfile%\.config\clink-scripts

wget https://raw.githubusercontent.com/chrisant996/clink-gizmos/refs/heads/main/fzf.lua
wget https://raw.githubusercontent.com/chrisant996/clink-gizmos/refs/heads/main/fuzzy_history.lua
wget https://raw.githubusercontent.com/chrisant996/clink-gizmos/refs/heads/main/cwdhistory.lua
wget https://raw.githubusercontent.com/chrisant996/clink-gizmos/refs/heads/main/tilde_autoexpand.lua
wget https://raw.githubusercontent.com/chrisant996/clink-gizmos/refs/heads/main/vscode_shell_integration.lua

clink installscripts %UserProfile%\.config\clink-scripts
clink set fzf.default_bindings true
clink set autosuggest.strategy match_prev_cmd history completion fuzzy_history

clink set history.max_lines 100000
clink set clink.logo none
```

### Алиасы для Clink {.unnumbered .unlisted}

См. соответвующую главу [*Алиасы и переменные окружения в консоли*](#алиасы-и-переменные-окружения-в-консоли).

### Настройка внешнего вида CommandPrompt для Clink

> [Clink поставляется](https://chrisant996.github.io/clink/clink.html#custom-prompts) с несколькими вариантами темы оформления командной строки, их можно попробовать не устанавливая:
  ```cmd
  clink config prompt list
  clink config prompt show <prompt_name>
  ```
> Для постоянного использования включить тему оформления командой:
  ```cmd
  clink config prompt use <prompt_name>
  ```

Существует проект [oh-my-posh](https://github.com/JanDeDobbeleer/oh-my-posh) для настройки вида командной строки для различных терминалов (CMD, PowerShell) с широкими возможностями настройки и [большим списком](https://ohmyposh.dev/docs/themes) уже преднастроенных вариантов. Включение oh-my-posh и выбор темы оформления:
```cmd
clink config prompt use oh-my-posh
clink set ohmyposh.theme %UserProfile%\scoop\apps\oh-my-posh\current\themes\peru.omp.json
```

Выбранная тема оформления [peru](https://ohmyposh.dev/docs/themes#peru) почти идеальна, единственный недостаток --- не отображает текущую папку в заголовке окна. Это исправляется модификацией темы оформления: сначала скопировать файл исходной темы в новый файл `peru-wtitle.omp.json`:
```cmd
mkdir %UserProfile%\.config\ohmyposh-themes
cd %UserProfile%\.config\ohmyposh-themes
cp %UserProfile%\scoop\apps\oh-my-posh\current\themes\peru.omp.json peru-wtitle.omp.json
```

затем добавить следующую строчку в файл `peru-wtitle.omp.json` почти в самый конец файла перед строкой `"version": 3`:
```cmd
"console_title_template": "{{ .Shell }}: {{ if .Segments.Session.SSHSession }}
{{ .UserName }}@{{ .HostName }}{{ end }}{{ if .WSL }}WSL: {{ end }}{{ .PWD }}",
```
(это одна строка, только она не помещается на ширину формата текста, поэтому записана в две строки).

Переключить на новую созданную тему:
```cmd
clink config prompt use oh-my-posh
clink set ohmyposh.theme %UserProfile%\.config\ohmyposh-themes\peru-wtitle.omp.json
```


### Использование Clink

[Списки горячих клавиш Clink](https://chrisant996.github.io/clink/clink.html#gettingstarted_keybindings); ниже приведены наиболее часто используемые.

_Автодополнение_ _Clink_ работает как в Linux:

* `Tab` --- непосредственно дополнить в случае отсутствия неоднозначностей.  В случае наличия вариантов они будут показаны, выбрать между ними вводом соответствующего символа и продолжить нажав `Tab`
* `<Right>` или `End` --- принять предложенное в строке автодополнение до конца строки
* `Alt+<Right>` --- принять предложенное в строке автодополнение на одно слово

В _Clink_ консоли доступны удобные [навигация и поиск](https://github.com/chrisant996/clink-fzf#how-to-use) по истории команд, навигация и поиск файлов:

* `Ctrl+R` --- интерактивный поиск по истории команд
* `Ctrl+T` --- интерактивный поиск по файлам и директориям в текущей директории
* `Alt+C` --- быстрый переход из текущей директории в поддиректорию или к файлу
* `Alt+B` --- интерактивный поиск по доступным горячим клавишам, и применение этих команд
* `Ctrl+Space` --- интерактивный поиск по текущему автодополнению
* поиск по `Tab` после `**` --- рекурсивному поиску по директориям и файлам в текущей директории
* `F7` --- открыть окно со списком последних команд
* `Up`/`Down` --- вверх/вниз по истории команд
* `PgUp`/`PgDown` --- вверх/вниз по истории команд с учётом уже набранной части команды
* `Shift+PgUp` --- интерактивное меню с историей посещённых директорий (при установленном _cwdhistory.lua_)
* `Ctrl+Alt+U` --- эквивалентно `cd ..` --- перейти в директорию выше
* `..` --- эквивалентно `cd ..`
* `...` --- эквивалентно `cd ../..`
* `cd /` или `cd \` --- перейти в корневую директорию
* `~` --- перейти в домашнюю директорию
* `c:`, `d:` --- переключиться на диск _C_, _D_ и т.д.
* `Ctrl+PgUp`/`Ctrl+PgDown` --- скрол консоли вверх/вниз.


Также удобное [редактирование](https://chrisant996.github.io/clink/clink.html#the-basics) команд в командной строке:

* `Ctrl+W` --- удалить слово слева от курсора
* `Ctrl+U` --- удалить всю команду слева от курсора и положить в "буфер"
* `Ctrl+Y` --- вставить из буфера (удалённое) по месту курсора
* `End`, `Home`, `Ctrl+<Left/Right>` --- навигация по тексту
* `Shift+End`, `Shift+Home`, `Shift+Ctrl+<Left/Right>` --- выделение текста в командной строке
* `Shift+Mouse` --- выделение мышкой в неприспособленных для этого программах


## Консольный терминал WindowsTerminal + Clink

После [установки и настройки Clink](#консольная-оболочка-clink-и-утилиты-busybox) останется только настроить профиль в WindowsTerminal.

Профиль для Clink в WindowsTerminal проще всего получить сдублировав профиль для _cmd.exe_, после чего в новом профиле в качестве запускаемой команды прописать:
```cmd
%SystemRoot%\System32\cmd.exe /k "clink inject"
```


## Консольный терминал Cmder/Conemu + Clink

[**Conemu**](https://conemu.github.io/en/)/[**Cmder**](https://cmder.app/) --- это универсальный консольный терминал с открытым исходным кодом, позволяющий запускать все консольные приложения: _Far_, _Putty_, _CMD_, _PowerShell_, _WSL_, и пр., в одинаково выглядящем терминальном текстовом окне, с одинаково настроенным типом и размером [_шрифта_](#отступление-про-шрифты), поведением горячих клавиш, размером окна.

[Git-for-Windows](https://gitforwindows.org/) --- это _git_,  скомпилированный для Windows; также содержит набор Linux команд, но эти команды не поддерживают wildcard globbing. Устанавливается автоматически при работе со _Scoop_. Используется в _Cmder_.

Some links: [WSL](https://conemu.github.io/en/wsl.html), [Pageant](https://github.com/cmderdev/cmder/wiki/Integrate-SSH-Agent-or-PuTTY-Agent), [Msys](https://conemu.github.io/en/CygwinMsysConnector.html), [256colors](https://conemu.github.io/en/Xterm256Colors.html).

После [установки _Clink_ и _BusyBox_](#консольная-оболочка-clink-и-утилиты-busybox), установить _Cmder_ или _Conemu_:
```cmd
scoop install cmder
```
```cmd
scoop bucket add extras
scoop install extras/conemu
scoop install extras/conemu-color-themes
```

Для использования _Clink_ в _Conemu_ необходимо добавить вызов самого Clink: в настройках Conemu _Settings > Startup > Tasks:_ модифицировать строку запуска Задачи/Task _{Cmd}_, заменив на
```cmd
cmd.exe /k "clink inject && %ConEmuBaseDir%\CmdInit.cmd"
```

### Настройки Cmder/Conemu {.unnumbered .unlisted}

* В Windows11 консольные программы в Cmder/Conemu могут неправильно отображать цвета, глючить --- в таком случае [надо снять галочку](https://github.com/Maximus5/ConEmu/issues/2384#issuecomment-1693076459) _Inject ConEmuHk_ в Cmder/Conemu в _Settings > Features: In-console options_; и выбрать цветовую схему _Monokai_.
* Для показа иконок в _Taskbar_'е в Windows должна быть включена опция _Show badges on taskbar buttons_ в _Settings > Personalization > Taskbar_.
* Одним из интересных вариантов интеграции Cmder в Windows будет настройка _Панели задач_ (_Taskbar_) без группировки окон --- чтобы каждый терминал был в отдельном окне Windows; при этом надо установить опции для открытия каждого терминала в новом окне в _Settings > General > Appearance: Generic_ убрать первые две галочки --- _Single instance, Multiple consoles_.
* Сменить фон на непрозрачный: _Settings > Features > Transparency_.
* Настроить шрифт: _Settings > General > Fonts_, требуется шрифт с набором иконок [NerdFonts](https://www.nerdfonts.com/font-downloads), любой из них можно установить с помощью [Scoop](https://scoop.sh/#/apps?q=nerd+font).
* Каждый терминал в своём окне: _Settings > General > Appearance: Generic > Single instance mode_ --- отключить.
* Разрешить мышку в _Far_: _Settings > Keys&Macro > Mouse: Mouse Options > Send mouse events to console_.
* При желании Табы можно расположить сверху, а не снизу: _Settings > General: Tabs > Tabs on bottom_.
* Настроить вид курсора: _Settings > Features > Text cursor_.
* Отключить проверку обновлений: _Settings > General > Update_.
* Комбинации `Ctrl+C`, `Ctrl+V`, `Ctrl+W`, `Ctrl+T` для доступности в консольных приложениях следует перенастроить (в настройках в _Cmder(Conemu) > Settings > Keys & Macro_) на варианты с `Shift`, т.е.: `Ctrl+Shift+C`, `Ctrl+Shift+V`, `Ctrl+Shift+W`, `Ctrl+Shift+T` и т.п.
* Действие клика правой кнопкой мыши настраивается в _Settings > Keys&Macro > Mouse: Mouse button actions_ -> сделать _Paste_.
* Cmder/Conemu имеет большое количество настроек, поэтому рекомендуется, разок его настроив, сохранить файл настроек ConEmu.xml, и в дальнейшем, применять его на других своих компьютерах.
* [mc](https://scoop.sh/#/apps?q=mc) под Windows: сменить диск: `Alt+D`

### Использование Cmder/Conemu {.unnumbered .unlisted}

Списки горячих клавиш: [Cmder](https://github.com/cmderdev/cmder#keyboard-shortcuts) ([Conemu](https://conemu.github.io/en/KeyboardShortcuts.html)) и [Clink](https://chrisant996.github.io/clink/clink.html#gettingstarted_keybindings); ниже приведены наиболее часто используемые.


Управление терминалами Cmder/Conemu:

* ``Ctrl+` `` --- глобальная комбинация клавиш вызова Cmder, не работает в поле ввода
* `Ctrl+Shift+T` --- диалог открытия новой вкладки/окна (по умолчанию `Ctrl+T`, см. _Настройки Cmder_ ниже)
* `Ctrl+Shift+W` --- закрыть вкладку/окно (по умолчанию `Ctrl+W`, см. _Настройки Cmder_ ниже)
* `Ctrl+D` --- завершить терминальную сессию, эквивалентно команде _exit_
* `Shift+Alt+#Number` --- открыть новую вкладку/окно по быстрому набору из меню открытия новых терминалов, см. `Win+Alt+T`
* `Alt+Enter`, `Ctrl+Win+Enter` --- Full Screen

Управление вкладками Cmder/Conemu работает когда все консоли открыты в одном окне Cmder/Conemu, а не когда каждый терминал в своём собственном окне. Управление вкладками:

* `Ctrl+#Number` --- переключиться на вкладку номер #Number
* `Ctrl+Tab` --- переключиться на следующую вкладку
* `Ctrl+Shift+Tab` --- переключиться на предыдущую вкладку

## Алиасы и переменные окружения в консоли

### Алиасы для Clink {.unnumbered .unlisted}

Алиасы в Windows создаются командой [`doskey`](https://learn.microsoft.com/ru-ru/windows-server/administration/windows-commands/doskey). В стартап-файле для Clink\
`%LOCALAPPDATA%\clink\clink_start.cmd` можно прописать соответствующие `doskey` команды:
```cmd
@echo off

set HOME=%UserProfile%
set LANG=en_US.utf8

doskey ll=ls --color=auto -lF $*
doskey l=ls --color=auto -lrtF $*
doskey ls=ls --color=auto -F $*

doskey sort=%UserProfile%\scoop\shims\sort.exe $*
doskey time=%UserProfile%\scoop\shims\time.exe $*

```

В результате в командной строке появятся привычные для Linux алиасы. В данном случае определены:\
`ls` --- выводит простой список файлов и папок,\
`ll` --- выводит подробный список файлов и папок,\
`l` --- подробный список, отсортированный по времени модификации файлов/папок.

В этом стартап файле так же можно прописать другие настройки, например, переменные окружения.

### Алиасы для Cmder {.unnumbered .unlisted}

В настройках в _Settings > Startup > Environment_ есть поле для стартовых настроек. В это поле можно добавить свои переменные окружения и алиасы:
```cmd
set LANG=en_US.utf8

unalias ll
unalias l
unalias ls

alias ll=ls --show-control-chars -F -l --color --ignore={"NTUSER.DAT*","ntuser.dat*"} $*
alias l=ls --show-control-chars -CFGNhplrt --color --ignore={"NTUSER.DAT*","ntuser.dat*"} $*
alias ls=ls --show-control-chars -CFGNhp --color --ignore={"NTUSER.DAT*","ntuser.dat*"} $*
```
(Ещё потребуется удалить соответствующие алиасы из файла\
`%HOME%\scoop\apps\cmder\current\config\user_aliases.cmd`)

### Алиасы для Conemu {.unnumbered .unlisted}

Аналогичные алиасы для Conemu, в _Settings > Startup > Environment_:
```cmd
set HOME=%HOMEDRIVE%%HOMEPATH%
set LANG=en_US.utf8
alias ll=ls --color=auto -lF $*
alias l=ls --color=auto -lrtF $*
alias ls=ls --color=auto -F $*
```

А можно использовать те алиасы, что настроены в _Clink_.

### Замечание про _HOME_

* Для _Clink_ переменную _HOME_ можно прописать в стартап файле\
  `%LOCALAPPDATA%\clink\clink_start.cmd`, см. раздел [Алиасы для Clink](#алиасы-для-clink).

* В случае с _WindowsTerminal_ переменную _HOME_ можно задать в переменных среды окружения для пользователя:
  ```cmd
  setx HOME "%UserProfile%"
  ```
  , либо, при использовании _Clink_, она в нём была прописана.

* _Cmder_ самостоятельно создаёт переменную _HOME_.

* В _Conemu_ переменную _HOME_ можно определить в настройках _Startup > Environment_ как `HOME=%HOMEDRIVE%%HOMEPATH%` или `HOME=%UserProfile%`.


## Neovim

[**Neovim**](https://neovim.io/) это обновлённый _Vim_, конфигурации для которого пишутся на вполне [понятном](https://learnxinyminutes.com/ru/lua/) [Lua](https://neovim.io/doc/user/lua-guide.html).

### Установка

Установка полноценного Neovim в Windows. Возможно какие-то пакеты уже были установлены --- scoop пропустит повторную установку:
```cmd
scoop install llvm
scoop install gcc
scoop install busybox
scoop install curl
scoop install luarocks
scoop bucket add versions
scoop install versions/lua51
scoop install python
scoop install ripgrep
scoop install fzf
scoop install fd
scoop install iconv
scoop install make
scoop install nodejs-lts
scoop install tree-sitter
scoop install yarn
scoop install neovim
```

Выйти и зайти заново в терминал, чтобы прописались пути для _python_ и проч., после выполнить:
```cmd
python -m pip install --upgrade pynvim
npm install -g neovim
```

Установить настроенную конфигурацию [kickstart.nvim](https://github.com/denius/kickstart.nvim) с предустановленным набором плагинов, и набор словарей для проверки правописания:
```cmd
git clone https://github.com/denius/kickstart.nvim.git %LOCALAPPDATA%\nvim

mkdir %LOCALAPPDATA%\nvim\spell
cd %LOCALAPPDATA%\nvim\spell

wget https://ftp.nluug.nl/pub/vim/runtime/spell/ru.utf-8.spl
wget https://ftp.nluug.nl/pub/vim/runtime/spell/en.utf-8.spl
wget https://ftp.nluug.nl/pub/vim/runtime/spell/en.utf-8.sug
wget https://ftp.nluug.nl/pub/vim/runtime/spell/ru.utf-8.sug

cd %HOME%
```

Запустить:
```cmd
nvim
```

_Note:_ если в Windows11 в Cmder/Conemu _nvim_ после запуска покажет чёрный экран, то [надо снять галочку](https://github.com/Maximus5/ConEmu/issues/2384#issuecomment-1693076459) _Inject ConEmuHk_ в Cmder/Conemu в _Settings > Features: In-console options_. И выбрать цветовую схему _\<Monokai\>_.
_Note:_ для 256-цветного терминала, возможно, потребуется [донастройка](https://conemu.github.io/en/VimXterm.html).

> *Пояснение о внутренней механике Neovim.*\
В Neovim за _синтаксис_ отвечает плагин [_treesitter_](https://tree-sitter.github.io/tree-sitter/), это парсер; в установленной конфигурации kickstart.nvim он уже установлен; treesitter самостоятельно заботится о парсинге всевозможных форматов. За _семантику_ отвечает встроенный плагин [_lsp.nvim_](https://neovim.io/doc/user/lsp.html); _LSP_ --- это аббревиатура для [_Language-Server-Protocol_](https://microsoft.github.io/language-server-protocol/overviews/lsp/overview/), универсального сервиса, который обеспечивает: проверку корректности кода и поиск ошибок, автодополнение, переход к определению, подсказки и т.д.; LSP --- это, де факто, стандарт в отрасли разработки, применяется во всех современных IDE и редакторах, в VSCode в том числе. Сервисы LSP для необходимых форматов устанавливаются отдельно, см. далее.

В процессе первого запуска nvim загрузит с интернета плагины в соответствии с конфигурацией kickstart.nvim.
Для загрузки и обновления плагинов вручную набрать `:Lazy` и `U`.

После выйти и заново войти в nvim, и набрать `:Mason` для запуска менеджера _LSP_-сервисов для настройки поддерживаемых языков программирования и форматов. В нём найти (`/`) строчку `clangd` и нажать `i` для установки поддержки языка C/C++; аналогично установить `fortls` для Fortran, `python-lsp-server` и `pyright` для Python. Для установки других форматов их следует поискать в списке существующих [LSP серверов](https://microsoft.github.io/language-server-protocol/implementors/servers/).

После всех настроек можно проверить, как всё это установилось, командой `:checkhealth`. Возможно будет указано несколько Warning: про pyenv, про недостающие языки типа ruby или php, но это не имеет принципиального значения. Основное --- надо убедиться что: а) плагин _treesitter_ (парсер) нормально заработал, и, что: б) плагин _LSP_ для нужного типа файлов работает --- LSP будет выводить отдельную диагностику для каждого типа файлов.


### Использование

#### _which-key_

В установленной конфигурации [kickstart.nvim](https://github.com/nvim-lua/kickstart.nvim) предустановлен плагин [which-key.nvim](https://github.com/folke/which-key.nvim), показывающий справку по клавишам при нажатии на клавишу `<Пробел>` (в kickstart.nvim на `<Пробел>` настроен `<Leader>`). То есть после нажатия на пробел будет показан список команд с ведущим `<Leader>`. Нажав _BackSpace_ (возврат) будет показан общий список комбинаций клавиш, причём некоторые из них многосимвольные (напр. _g_, _z_, _\[_ и пр.), их списки буду раскрыты при нажатии на соответствующий символ.

#### Поиск

Также, среди предустановленных есть плагин [Telescope.nvim](https://github.com/nvim-telescope/telescope.nvim#usage), позволяющий в интерактивном режиме производить _поиск_ по всему что есть в редакторе: файлу, файлам, истории, поиск файлов; посмотреть состояние настроек и переменных, клавиатурные сочетания; позволяет сменить тему оформления: `:Telescope colorscheme` (например _shine_, _wildcharm_). В целом, все данные, которые есть в редакторе доступны через этот плагин. Запускается через команду `:Telescope <TAB>`, высветится список возможностей _Telescope_, выбрать и применить. Список преднастроенных в kickstart.nvim комбинаций клавиш (в режиме NORMAL) для _Telescope_:

* `<leader>sh` --- [S]earch [H]elp
* `<leader>sk` --- [S]earch [K]eymaps
* `<leader>sf` --- [S]earch [F]iles
* `<leader>ss` --- [S]earch [S]elect Telescope
* `<leader>sw` --- [S]earch current [W]ord
* `<leader>sg` --- [S]earch by [G]rep
* `<leader>sd` --- [S]earch [D]iagnostics
* `<leader>sr` --- [S]earch [R]esume
* `<leader>s.` --- [S]earch Recent Files ("." for repeat)
* `<leader><leader>` --- [ ] Find existing buffers
* `<leader>/` --- [/] Fuzzily search in current buffer
* `<leader>s/` --- [S]earch [/] in Open Files
* `<leader>sn` --- [S]earch [N]eovim files

#### Русский язык и правописание

В установленной конфигурации, включение-выключение подсветки проверки правописания будет происходить по команде `<LocalLeader>s` = `\s`, а переключение языка по `Ctrl-6` (в документации обозначается как `Ctrl-^`) в режиме редактирования (INSERT) или режиме команд (COMMAND), в нормальном режиме (NORMAL) команда `Ctrl-^` не работает. Для режима команд индикатор текущей кодировки не отображается.

#### Некоторые команды и настройки Neovim

* В меню выбора из командной строки, стрелки влево/вправо бегают по вариантам, например, набрать `:colorscheme ` и `<Tab>`, появится меню, перемещаться по которому следует клавишами влево-вправо, `Ctrl-Y` или `<Enter>` --- [выбрать](https://neovim.io/doc/user/options.html#'wildmenu').

* В меню _autocomplete_, при редактировании в режиме INSERT, выбор варианта производится стрелками _вверх_/_вниз_, а окончательный выбор --- `Ctrl-Y` (_Y_, это от _Yes_).

* `Alt-1`, `Alt-2`, ... --- переключиться на таб №; `<LocalLeader>h`, `<LocalLeader>l` --- переключение между табами (это кастомная настройка).

* `*` в режиме NORMAL --- поиск слова под курсором.

* `gcc`/`gc` --- закоментировать-раскоментировать строку или выбранную область, в нормальном и визуальном режимах, соответственно.

* `[d` и `]d` --- переход к предыдущему или следующему диагностическому сообщению LSP. `<C-W>d` --- открыть окошко под курсором для вывода сообщения LSP полностью.

* LSP не только подсвечивает ошибки, но также может некоторые из них исправлять --- при этом он высветит сообщение _fix available_. Комбинация `<Leader>ca` (вызывает _:vim.lsp.buf.code_action()_) производит исправление.

* На `<LocalLeader>p` настроен показ истории yank (буфера копи-пасты).

* Для перманентной смены схемы подсветки её необходимо прописать в конце файла\
  _%HOME%\\AppData\\Local\\nvim\\init.lua_ в виде строки `vim.cmd.colorscheme 'wildcharm'` (здесь _wildcharm_ --- это название схемы), плюс определить вариант light/dark, если у схемы есть такой выбор: `vim.o.background = 'light'`.

* В Windows также можно настроить работу Neovim через WSL, и запускать его: `wsl vi somefile`.

#### Документация

<https://neovim.io/doc/user/>

[Команды nvim на stackoverflow](https://stackoverflow.com/questions/5400806/what-are-the-most-used-vim-commands-keypresses).

Есть множество шпаргалок по командам Vim/Neovim, например: <https://devhints.io/vim>.

Если что-то непонятно в Vim, то всегда можно спросить ИИ, например, [DeepSeek](https://chat.deepseek.com/) или [Qwen](https://chat.qwen.ai/). Также, они всегда могут подсказать команды для того или иного действия.




# _Приложение:_ Виртуалки

## Управление Docker'ом

Docker работает с контейнерами (виртуальными машинами) (containers), образами (images), и томами (volumes). _Контейнер_ --- это набор из _образ_ + _том_.

При скачивании или создании виртуальной машины (контейнера) Docker создаёт _образ_ (_image_), который не изменяется, он _read-only_. _Образ_ --- это несколько файлов, со специальной внутренней структурой в виде файловой системы OverlayFS, т.е. внутри нескольких файлов, из которых состоит _образ_, хранится множество других файлов. Файловая система OverlayFS характерна тем, что она может хранить несколько версий одного и того же файла, но показываться будет только самая "верхняя" версия файла. _Образ_ состоит из слоёв --- при создании или обновлении виртуалки на него накатываются новые слои, может какие-то слои откатываются и переписываются, или вообще стираются. В нижележащем слое образа, как правило, хранится слепок операционной системы в самом минимальном виде, какой только может быть. На последующих слоях образа хранятся файлы тех или иных программ и библиотек, которые были добавлены при создании образа. `docker images` --- вывести список всех хранимых образов.

При запуске _контейнера_ все созданные в процессе работы данные записываются в _том_ (_volume_). Если при запуске контейнера была указана опция `--rm`, то использовавшийся при работе _том_ будет удалён после окончания работы контейнера. `docker volume ls` --- список сохранённых томов. Данные постоянно хранятся в томах, в том числе между запусками контейнеров; хранятся пока не будет удалён содержащий их контейнер --- `docker container rm <container id>`, либо не будет удалён вручную --- `docker volume rm <volume id>`.

`docker container ls` --- список запущенных контейнеров, `docker container ls -a` --- список всех контейнеров в системе.

В Windows и образы и тома хранятся в одном файле:\
`C:\Users\user\AppData\Local\Docker\wsl\disk\docker_data.vhdx` --- удобно для контроля занимаемого места (см. так же утилиту _WinDirStat_).

### Запуск Docker контейнеров {.unlisted}

Самостоятельно формировать команды запуска Docker контейнеров вряд ли придётся, но для понимания запускаемых строчек краткое пояснение опций запуска команды `docker run `:

* `-t` --- запуск в консольном режиме;
* `-i` --- запуск в интерактивном режиме;
* `-d` --- запустить виртуалку в бэкграунде, т.е. она продолжит работать фоновом режиме;
* `-v path1:path2` --- смонтировать локальный путь `path1` внутри контейнера в точке `path2`; это требуется чтобы работать с локальными данными изнутри контейнера;
* `--rm` --- удалить созданные контейнером данные после завершения работы контейнера, т.е. удаляется соответствующий том (данные из папок, смонтированных с `-v`, не затрагиваются);
* `--name some-container-name` --- задаёт имя для созданного контейнера.

После создания контейнера командой `docker run ` все опции запуска будут сохранены внутри контейнера, их более не придётся где-либо вводить.

Используя имя созданного контейнера его в дальнейшем можно запускать и останавливать короткими командами:
```cmd
docker start some-container-name
```
```cmd
docker stop some-container-name
```

## Backup/Restore WSL систем

Посмотреть какие WSL системы установлены, какая основная:
```cmd
wsl -l -v
```

Скопировать/забэкапить WSL систему, здесь _Ubuntu_ --- название WSL системы, которая будет забэкаплена:
```cmd
wsl --export Ubuntu D:\backup\ubuntu-24.04-20241117.tar
```

Восстановить из бэкапа, здесь _ubuntu2_ название новой WSL системы, путь `C:\wsl\ubuntu` --- место где будет лежать файл-контейнер _.vhdx_ с новой восстановленной системой (чтобы далеко не прятался и можно было глянуть сколько места занимает):
```cmd
wsl --import ubuntu2 C:\wsl\ubuntu D:\backup\some-file.tar
```

После восстановления из бэкапа новой машины необходимо указать пользователя по-умолчанию: `ubuntu2.exe config --default-user aero`, где _ubuntu2.exe_, это название новой VM, для которой Windows автоматически создаст приложение для запуска.

Сделать _ubuntu2_ основной, запускаемой по умолчанию: `wsl -s ubuntu2`

В дальнейшем можно будет удалить старую WSL машину: `wsl --unregister Ubuntu`, при этом все данные внутри неё будут потеряны. Для безопасности лучше сначала импортировать в новое имя, установить её по-умолчанию, поработать с новой, а потом уже удалять старую --- при работе через команду `wsl` название виртуалки не имеет значения.

### Установка произвольных Linux {.unlisted}

Аналогичным способом, из архива, можно создать [новую Linux систему](https://learn.microsoft.com/ru-ru/windows/wsl/use-custom-distro) на компьютере, скопировав и установив соответствующий дистрибутивный файл Linux-системы с интернета, например со страницы проекта [wsldl](https://wsldl-pg.github.io/docs/Using-wsldl/).

#### Fedora {.unnumbered .unlisted}

*\<TBD\>*

<https://fedoraproject.org/wiki/Changes/FedoraWSL>

_Fedora_ имеет преимущество перед _Ubuntu_, так как _RedHat_/_Fedora_ --- это изначально ориентированный на _HPC_ Linux дистрибутив, и в нём лучше поддержка параллелизации, отладки Fortran, и прочим разделам высокопроизводительных вычислений.



### Импортирование локальных образов с Docker {.unlisted}

Docker также [может импортировать](https://andygreen.phd/2022/01/26/converting-vm-images-to-docker-containers/) бэкапы полноценных Linux систем (не WSL) в виде _.tar.gz_ архива:
```cmd
docker import <filename> <repository>:<tag>
```
```cmd
docker import some-linux-backup.tar.gz linux-test:1.0
```

С последующим запуском
```cmd
docker run -i -t <image id> <commands>
```

где в качестве _\<commands\>_ для Linux может выступать _/bin/bash_; _\<image id\>_ посмотреть командой `docker images`:

```cmd
docker images
docker run -i -t linux-test:1.0 /bin/bash
```

Таким методом можно создавать/копировать и запускать виртуалки с Linux (например, с менеджерами лицензий, и т.п.) из бэкапов, созданных с помощью команды `tar` изнутри копируемой Linux системы:
```cmd
tar --one-file-system -cvpzSf /mnt/backup/some-ubuntu-backup.tar.gz / /boot --exclude="/mnt/*"
```


# _Приложение:_ Дистрибуция продуктов Microsoft


## BitLocker

[BitLocker](https://learn.microsoft.com/ru-ru/windows/security/operating-system-security/data-protection/bitlocker/) --- это встроенный в Windows механизм шифрования дисков для обеспечения безопасности информации. По умолчанию, при использовании учётной записи Microsoft, при установке Windows диск C: будет автоматически зашифрован. При форматировании новых дисков (например D:), они тоже будут зашифрованы, если C: был зашифрован.

Windows в процессе загрузки открывает ключ шифрования и начинает прозрачно для пользователя расшифровывать данные на диске, т.е. пользователь не замечает, что файлы зашифрованы. Но, если, этот диск вынуть, и подключить к другому компьютеру, то без ключей шифрования считать информацию с него не удастся --- он зашифрован.

Ключи шифрования хранятся: на диске C:, в модуле [TPM](https://ru.wikipedia.org/wiki/BitLocker) (если есть), в [облаке](https://account.microsoft.com/devices/recoverykey) учётной записи пользователя Microsoft; так же их можно экспортировать в разделе _Управление BitLocker_ (48 цифр).

При создании только локальной учётной записи BitLocker автоматически не включается, и шифрование не проводится (хотя его можно активировать вручную).

При переустановке Windows важно учитывать, что если на компьютере, помимо системного диска C:, были другие зашифрованные диски, то без входа в учётную запись Microsoft они так и останутся зашифрованы. Если в планах использование только локальной учётной записи, перед переустановкой необходимо, либо отключить шифрование BitLocker (что приведёт к дешифровке дисков), либо убедиться, что ключи шифрования сохранены и доступны для использования.


## OEM, Retail или Volume?

Лицензии OEM --- это лицензии на ПО, поставляемые производителями и сборщиками техники вместе с новыми ноутбуками и компьютерами. Microsoft выделяет производителям техники целые пулы OEM лицензий по небольшой цене. И, по Европейским законам, производители могут продавать не только продукт целиком, но и комплектующие к нему, и, в данном случае, они могут продавать эти лицензии отдельно от компьютерной техники. Каждая OEM лицензия входит в какой-то конкретный пул лицензий, который закреплён за конкретным производителем, т.е., OEM, это не какая-то абстрактная безликая лицензия, а выпущенная определённым производителем. В целом, покупка OEM лицензии достаточно безопасна, случаев отзыва пулов лицензий очень и очень немного. Из особенностей OEM лицензии следует отметить, что она, в отличии от Retail или Volume лицензий, "одноразовая", то есть, активировав её один раз, _ключ_ нельзя применить второй раз, и программу нельзя будет переустановить или перенести на другой компьютер. Не может быть активирована сервисом KMS.

Retail (розничная) лицензия --- это привычная "коробочная" (FPP) версия из магазина, сейчас может поставляться в виде электронного ESD ключа. Эту лицензию можно переустановить (для MSOffice не более трёх раз) на другой компьютер (на старом, естественно, лицензия перестанет работать). Должна быть активирована в течении месяца с момента установки. Не может быть активирована сервисом KMS.

Volume (VL), это (корпоративные) лицензии для большого количества лицензий (от 5 штук) --- поштучно не продаются. Помимо коммерческих предприятий часто используются в образовательных учреждениях. Volume лицензии активируются с помощью KMS сервиса --- службы предоставляемой сервером. Активации с помощью KMS сервиса по локальной сети, это совершенно стандартная процедура, которая происходит автоматически для продуктов с Volume лицензией при правильной настройке свойств локального сетевого подключения (при получении IP-адреса, по DHCP, в качестве DNS сервера будет прописан адрес KMS сервиса). В случае подсоединения через интернет, возможность KMS активации ограничена.

* OEM --- может быть установлена только один раз. Эту лицензию нельзя перенести на другой компьютер. Должна быть активирована в течении месяца с момента установки.
* Retail --- лицензию можно переустановить на другой компьютер (MSOffice не более трёх раз). Должна быть активирована в течении месяца с момента установки.
* Volume --- Использует не ключи, а сервисы лицензий KMS. Нет ограничений на перенос на другой компьютер.


## Выбор версии MSOffice

_Аргументы против обновления версии MSOffice:_ Все последние [версии MSOffice](https://en.wikipedia.org/wiki/Microsoft_Office#History_of_releases), начиная с 2016, это всё одна версия 16.0, т.е., по сути, все новые Офисы, это 16 версия с сервис-паками, ответственными за улучшения интерфейса, но не принципиальные изменения. Единственное препятствие к работе в прошлых Офисах, это окончание срока поддержки и прекращение обновлений (безопасности). Поэтому, если никакой MSOffice не установлен, то следует устанавливать самую новую версию, если же MSOffice версий 2016 (или новее) уже установлен и устраивает, то пусть и стоит.

_Аргументы за обновление версии MSOffice:_ Изменения пользовательского интерфейса, а значит и пользовательского удобства могут улучшаться с новыми версиями; например, в PowerPoint, появилось выравнивание элементов на слайде (я не помню с какой версии), и это значительно улучшило удобство использования. Поэтому, по возможности, следует опробовать новые версии MSOffice на предмет улучшения удобства использования, и, если офис стал лучше, то переустанавливать на более новый.

_LTSC (Long-Term Servicing Channel)_ --- это версия Офиса для корпоративного сегмента, где после установки в процессе эксплуатации не должен как-либо меняться функционал или преднастройки; поэтому, _LTSC_, это версия Офиса с обновлениями безопасности, но без обновления функционала. Поэтому, при возможности выбора, лучше установить полноценную версию с _Current_ канала; но, если _LTSC_-версия уже установлена, то и ладно.

*Office 365* --- это офис с ежемесячной или ежегодной подпиской, требует постоянного подключения к интернету. Сейчас, в отсутствии возможности оплачивать онлайн, ни в коем случае не стоит связываться с _Office 365_. _Note:_ Сейчас Microsoft старается продвигать только _Office 365_, а все упоминания об обычном бессрочном автономном Офисе удалены со страниц сайта Microsoft.

### Дистрибутивы автономного MSOffice:

* Office Home & Student --- Word, Excel, PowerPoint, OneNote;
* Office Home & Business --- + Outlook;
* ~~Office Standard --- + Publisher, Web Apps;~~ сейчас не продаётся;
* ~~Office Professional --- + Access, SharePoint Workspace;~~ сейчас не продаётся;
* Office Professional Plus --- + InfoPath, Skype for Business или Lync или Microsoft Teams, OneDrive for Business (ранее был SharePoint Workspace).

_Note:_ Раньше (2003) редактор математических формул был только в Professional версии, как обстоит дело сейчас давно никто не проверял. *CHECKME:* *\<TBD\>*

### Итого по выбору _MS Office_:

* **если не используется MS Access, то Office Home или Student _абсолютно достаточно_!**

* **если установлен офис версии 2016 (или новее) и он устраивает, то обновляться не требуется;**

* **если офис не установлен, то следует устанавливать самую последнюю версию (2024) с канала _Current_.**


## UUP (Unified Update Platform) --- загрузка MS Windows


> Загрузка с портала _Microsoft Unified Update Platform_, это официальный способ получения установочных пакетов и обновлений для продуктов Microsoft.

Для установки рекомендуется использовать версию _build 22631.3296_ (_23H2_). Это версия, с одной стороны, достаточно свежая, чтобы были драйвера для новых ноутов, а с другой стороны, эта версия всё ещё позволяет при установке создать локальную учётную запись без необходимости онлайн регистрации учётной записи Microsoft (можно использовать и более новые версии при настройке с помощью _Rufus_, см. далее в [_Создание загрузочной флешки_](#создание-загрузочной-флешки)).


### uupdump.net

**<https://uupdump.net/>** --- это сайт для создания скрипта, который скачает с сайта Microsoft и создаст загрузочный iso-образ Windows. Сайт <https://uupdump.net/>, возможно, недоступен в России, в этом случае следует воспользоваться другим вариантом.

Использование: на сайте выбрать желаемую версию, понажимать далее, в процессе отказаться от скачивания последних обновлений, и, скачать zip-архив (небольшой). Этот архив распаковать в папку на диске с достаточным количеством свободного места (12&nbsp;ГБ?), и запустить скрипт из распакованного архива, `uup_download_windows.cmd` (выполняется около часа). Если есть сомнения какую версию выбрать, то вот [ссылка](https://uupdump.net/download.php?id=07dd20c8-a2de-4792-a336-2ab01b43a160&pack=en-us&edition=professional) на Windows11 23H2 (4.8&nbsp;ГБ). ([Руководство](https://www.comss.ru/page.php?id=9320).)


### UUPMediaCreator

[**UUPMediaCreator**](https://github.com/gus33000/UUPMediaCreator), кроссплатформенная^[можно загрузить и в Linux/MacOS] утилита, которая позволяет скачать и создать установочный ISO-образ с операционной системой Windows. Этот iso-образ создаётся по официальной методике получения образов и обновлений c официального сайта Microsoft Unified Update Platform.

Установка:
```cmd
scoop bucket add hoilc_scoop-lemon https://github.com/hoilc/scoop-lemon
scoop install hoilc_scoop-lemon/uupmediacreator
```

[Использование](https://www.comss.ru/page.php?id=9724). Перейти в папку, где будет создаваться загрузочный iso-образ, выполнить загрузку^[Потребуется до 12&nbsp;ГБ свободного места] (22631.3296 соответствует 23H2):
```cmd
UUPDownload -s Professional -v 10.0.22621.1 --r Retail -b Retail -c ni_release -t amd64 -l en-us -y 10.0.22631.3296
```

Запустить^[UUPMediaConverter выполняется полчаса] сборку iso-диска (здесь надо подставить путь куда скачались файлы):
```cmd
sudo UUPMediaConverter -l en-us -u "path-to-downloaded-files" -i Win11-23H2.iso -e Professional
```

### Создание загрузочной флешки

Подготовить загрузочную флешку из загруженного iso-образа можно с помощью утилиты [**Rufus**](https://rufus.ie/) под Windows, или [**mkusb**](https://help.ubuntu.com/community/mkusb) под Linux.

[Установка](https://winstall.app/apps/Rufus.Rufus) _Rufus_:
```cmd
winget install --id=Rufus.Rufus -e
```

_Rufus_ позволяет при создании сделать _Customize Windows Installation_, а именно _запрет_ на: проверку ограничений, сбор данных (телеметрию), онлайн регистрацию. При выборе типа загрузки следует выбирать _GPT/SecureBoot_, а не _MBR/Legacy_ (который предназначен для очень старых компьютеров).



## ODT (Office Deployment Tool) --- загрузка MS Office

[**ODT**](https://www.microsoft.com/en-us/download/details.aspx?id=49117) --- _Microsoft Office Deployment Tool_, _Средство Развертывания Office_, официальный инструмент для: выбора конфигурации MSOffice для загрузки, загрузки MSOffice, и установки. [Официальный обзор](https://learn.microsoft.com/ru-ru/microsoft-365-apps/admin-center/overview-office-customization-tool).


Получение утилиты развёртывания _ODT_:

* Либо скачать по [ссылке](https://www.microsoft.com/en-us/download/details.aspx?id=49117) _officedeploymenttool.exe_ и распаковать этот самораспаковывающийся архив в папку куда будет загружаться офис;

* Либо установить
  ```cmd
  winget install --id=Microsoft.OfficeDeploymentTool -e
  ```
  и скопировать файлы из *"C:\\Program Files\\OfficeDeploymentTool"* в нужную папку.

В любом случае в папке для закачки будут необходимы два файла: _setup.exe_ и _configuration-Office365-x64.xml_.

Поставляемый `configuration-Office365-x64.xml` скопировать в `configuration.xml`, и отредактировать спецификацию загружаемого офиса, [инструкция](https://learn.microsoft.com/ru-ru/microsoft-365-apps/deploy/office-deployment-tool-configuration-options).

* При выборе загружаемой версии офиса потребуется его идентификатор, который можно найти на сайте ["Список идентификаторов продуктов, поддерживаемых средством развертывания Office для запуска"](https://learn.microsoft.com/ru-ru/microsoft-365/troubleshoot/installation/product-ids-supported-office-deployment-click-to-run).
* [Список возможных исключений](https://learn.microsoft.com/ru-ru/microsoft-365-apps/deploy/office-deployment-tool-configuration-options#id-attribute-part-of-excludeapp-element): _"Access"_, _"Bing"_, _"Excel"_, _"Groove"_, _"Lync"_, _"OneDrive"_, _"OneNote"_, _"Outlook"_, _"OutlookForWindows"_, _"PowerPoint"_, _"Publisher"_, _"Teams"_, _"Word"_.
* Опция  _\<Remove All="True" /\>_ указывает перед установкой удалить все установленные версии MSOffice.


Пример конфигурации `configuration.xml` для загрузки дистрибутива версии _ProPlus2024Volume_, но без всех корпоративных или облачных опций, в результате в дистрибутиве должны остаться только _Word_, _Excel_, _PowerPoint_, _Visio_, _MSProject_:

```xml
<Configuration>
  <Add OfficeClientEdition="64" Channel="Current">
    <Product ID="ProPlus2024Volume">
      <Language ID="ru-ru" />
      <Language ID="en-us" />
      <!-- <ExcludeApp ID="Access "/> -->
      <ExcludeApp ID="Bing "/>
      <ExcludeApp ID="Groove "/>
      <ExcludeApp ID="Lync "/>
      <ExcludeApp ID="OneDrive "/>
      <ExcludeApp ID="OneNote "/>
      <ExcludeApp ID="Outlook "/>
      <ExcludeApp ID="OutlookForWindows "/>
      <ExcludeApp ID="Publisher "/>
      <ExcludeApp ID="Teams "/>
    </Product>
    <Product ID="VisioPro2024Volume">
      <Language ID="ru-ru" />
      <Language ID="en-us" />
    </Product>
    <Product ID="ProjectPro2024Volume">
      <Language ID="ru-ru" />
      <Language ID="en-us" />
    </Product>
  </Add>
  <Remove All="True" />
  <!--  <RemoveMSI All="True" /> -->
  <!--  <Display Level="None" AcceptEULA="TRUE" />  -->
  <!--  <Property Name="AUTOACTIVATE" Value="1" />  -->
</Configuration>
```

Пример конфигурации `configuration.xml` для загрузки дистрибутива с непосредственно выбранными _Word_, _Excel_ и _PowerPoint_ без облачных опций _OneDrive_:

```xml
<Configuration>
  <Add OfficeClientEdition="64" Channel="Current">
    <Product ID="Word2024Volume">
      <Language ID="ru-ru" />
      <Language ID="en-us" />
      <ExcludeApp ID="OneDrive "/>
    </Product>
    <Product ID="PowerPoint2024Volume">
      <Language ID="ru-ru" />
      <Language ID="en-us" />
      <ExcludeApp ID="OneDrive "/>
    </Product>
    <Product ID="Excel2024Volume">
      <Language ID="ru-ru" />
      <Language ID="en-us" />
      <ExcludeApp ID="OneDrive "/>
    </Product>
  </Add>
  <Remove All="True" />
  <!--  <RemoveMSI All="True" /> -->
  <!--  <Display Level="None" AcceptEULA="TRUE" />  -->
  <!--  <Property Name="AUTOACTIVATE" Value="1" />  -->
</Configuration>
```

Перед скачиванием [изменить регион для _ODT_ на _US_](https://habr.com/ru/articles/820343/), иначе из-за санкций утилита не начнёт загрузку:
```cmd
reg add "HKCU\Software\Microsoft\Office\16.0\Common\ExperimentConfigs\Ecs" /v "CountryCode" /t REG_SZ /d "std::wstring|US" /f
```

Запустить загрузку:
```cmd
setup.exe /download configuration.xml
```

Установить загруженный офис:
```cmd
setup.exe /configure configuration.xml
```

После установки открыть любое приложение MSOffice, Word например; снизу слева будет меню _Учетная запись_, в нём выбрать _Активировать..._.

### Office Tools Plus

Ещё есть программа с графическим интерфейсом _Office Tool Plus_ <https://otp.landian.vip/en-us/>, в которой все вышеописанные действия можно сделать в графическом интерфейсе. Также, умеет активировать Офис с помощью KMS сервисов, расположенных в интернете.

```cmd
scoop install extras/office-tool-plus
```



# _Приложение:_ Документация и ссылки

[Windows 10/11 Guide. Including Windows Security tools, Encryption, Nextcloud, Graphics, Gaming, Virtualization, Windows Subsystem for Linux (WSL 2), Software Apps, and Resources.](https://github.com/mikeroyal/Windows-11-Guide)

[Большая база заметок по работе в PowerShell и смежным командам на русском языке.](https://github.com/Lifailon/PS-Commands/blob/rsa/posh.md)

[Заметки по работе с системными командами и консольными утилитами Linux для Windows пользователей.](https://github.com/Lifailon/PS-Commands/blob/rsa/linux.md)

[Огромный гайд по настройке рабочего окружения: Linux, VScode, Python](https://habr.com/ru/companies/timeweb/articles/916040/).
